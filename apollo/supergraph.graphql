schema
  @core(feature: "https://specs.apollo.dev/core/v0.2"),
  @core(feature: "https://specs.apollo.dev/join/v0.1", for: EXECUTION)
{
  query: Query
  mutation: Mutation
}

directive @core(as: String, feature: String!, for: core__Purpose) repeatable on SCHEMA

directive @join__field(graph: join__Graph, provides: join__FieldSet, requires: join__FieldSet) on FIELD_DEFINITION

directive @join__graph(name: String!, url: String!) on ENUM_VALUE

directive @join__owner(graph: join__Graph!) on INTERFACE | OBJECT

directive @join__type(graph: join__Graph!, key: join__FieldSet) repeatable on INTERFACE | OBJECT

type ActionBlock {
  actionType: ActionType!
  entryPoint: EntryPoint!
  exitPoint: ExitPoint!
  params: [VariableExpression!]!
  workOrderType: WorkOrderType
  workerType: WorkerType
}

input ActionBlockInput {
  actionType: ActionTypeId!
  cid: String!
  params: [VariableExpressionInput!]!
  uiRepresentation: BlockUIRepresentationInput
}

type ActionType {
  description: String!
  id: ActionTypeId!
  variables: [VariableDefinition!]!
}

enum ActionTypeId {
  update_inventory
  update_workforce
  work_order
  worker
}

type Activity implements Node {
  activityType: ActivityField!
  author: User
  clockDetails: ClockDetails
  createTime: Time!
  id: ID!
  isCreate: Boolean!
  newRelatedNode: Node
  newValue: String
  oldRelatedNode: Node
  oldValue: String
  workOrder: WorkOrder!
}

enum ActivityField {
  ASSIGNEE
  CLOCK_IN
  CLOCK_OUT
  CREATION_DATE
  DESCRIPTION
  NAME
  OWNER
  PRIORITY
  STATUS
}

input ActivityFilterInput {
  activityType: ActivityField!
  limit: Int!
  orderDirection: OrderDirection!
}

input AddAlarmFilterInput {
  alarmStatus: ID
  beginTime: Time!
  creationTime: Time!
  enable: Boolean!
  endTime: Time!
  name: String!
  networkResource: String!
  reason: String!
  user: String!
}

input AddAlarmStatusInput {
  name: String!
}

input AddAppointmentInput {
  assigneeID: ID!
  creatorId: ID
  date: Time!
  duration: Float!
  workorderID: ID!
}

input AddBlockInstanceInput {
  blockId: ID!
  inputJSON: String
  inputs: [VariableValueInput!]
  outputJSON: String
  outputs: [VariableValueInput!]
  startDate: Time!
  status: BlockInstanceStatus
}

input AddBulkServiceLinksAndPortsInput {
  id: ID!
  linkIds: [ID!]
  portIds: [ID!]
}

input AddCMVersionInput {
  parameters: [ParameterRef!]!
  previous: CMVersionRef
  status: VersionStatus!
  validFrom: DateTime
  validTo: DateTime
}

type AddCMVersionPayload {
  cMVersion(filter: CMVersionFilter, first: Int, offset: Int, order: CMVersionOrder): [CMVersion]
  numUids: Int
}

input AddChangeItemInput {
  booleanValue: Boolean
  floatValue: Float
  intValue: Int
  latitudeValue: Float
  longitudeValue: Float
  parameterType: ConfigurationParameterTypeRef!
  rangeFromValue: Float
  rangeToValue: Float
  resource: ResourceRef
  status: ChangeItemStatus!
  stringValue: String
}

type AddChangeItemPayload {
  changeItem(filter: ChangeItemFilter, first: Int, offset: Int, order: ChangeItemOrder): [ChangeItem]
  numUids: Int
}

input AddChangeRequestActivityInput {
  activityType: ChangeRequestActivityField!
  changeRequest: ChangeRequestRef!
  createTime: DateTime!
  isCreate: Boolean!
  newValue: String
  oldValue: String
}

type AddChangeRequestActivityPayload {
  changeRequestActivity(filter: ChangeRequestActivityFilter, first: Int, offset: Int, order: ChangeRequestActivityOrder): [ChangeRequestActivity]
  numUids: Int
}

input AddChangeRequestInput {
  activities: [ChangeRequestActivityRef]
  description: String!
  items: [ChangeItemRef!]!
  scheduler: SchedulerConfigRef
  source: ChangeRequestSource
  status: ChangeRequestStatus!
  type: ChangeRequestType
}

type AddChangeRequestPayload {
  changeRequest(filter: ChangeRequestFilter, first: Int, offset: Int, order: ChangeRequestOrder): [ChangeRequest]
  numUids: Int
}

input AddComparatorInput {
  name: String!
}

input AddComposed_ofInput {
  resource: ResourceRef
}

type AddComposed_ofPayload {
  composed_of(filter: Composed_ofFilter, first: Int, offset: Int): [Composed_of]
  numUids: Int
}

input AddConfigParamTagInput {
  name: String!
  parameters: [ConfigurationParameterTypeRef]!
}

type AddConfigParamTagPayload {
  configParamTag(filter: ConfigParamTagFilter, first: Int, offset: Int, order: ConfigParamTagOrder): [ConfigParamTag]
  numUids: Int
}

input AddConfigurationParameterTypeInput {
  booleanValue: Boolean
  category: String
  externalId: String
  floatValue: Float
  index: Int
  intValue: Int
  isDeleted: Boolean
  isEditable: Boolean
  isListable: Boolean
  isMandatory: Boolean
  isPrioritary: Boolean
  latitudeValue: Float
  longitudeValue: Float
  mappingIn: String
  mappingOut: String
  name: String!
  nodeType: String
  parameters: [ParameterRef!]
  rangeFromValue: Float
  rangeToValue: Float
  rawValue: String
  stringValue: String
  tags: [ConfigParamTagRef!]
  type: ParameterKind!
}

type AddConfigurationParameterTypePayload {
  configurationParameterType(filter: ConfigurationParameterTypeFilter, first: Int, offset: Int, order: ConfigurationParameterTypeOrder): [ConfigurationParameterType]
  numUids: Int
}

input AddCounterFamilyInput {
  name: String!
}

input AddCounterFormulaInput {
  counterFk: ID!
  formulaFk: ID!
  mandatory: Boolean!
}

input AddCounterFormulaListInput {
  counterList: [CounterListInput]!
  formulaFk: ID!
}

input AddCounterInput {
  counterFamily: ID!
  externalID: String!
  name: String!
  networkManagerSystem: String!
  vendorFk: ID!
}

input AddCustomerInput {
  externalId: String
  name: String!
}

input AddDomainInput {
  name: String!
}

input AddEquipmentInput {
  externalId: String
  location: ID
  name: String!
  parent: ID
  positionDefinition: ID
  properties: [PropertyInput!]
  type: ID!
  workOrder: ID
}

input AddEquipmentPortTypeInput {
  linkProperties: [PropertyTypeInput!]
  name: String!
  properties: [PropertyTypeInput!]
}

input AddEquipmentTypeInput {
  category: String
  name: String!
  ports: [EquipmentPortInput!]
  positions: [EquipmentPositionInput!]
  properties: [PropertyTypeInput!]
}

input AddEventSeverityInput {
  name: String!
}

input AddFilesInput {
  annotation: String
  category: String
  contentType: String!
  documentCategoryId: ID
  fileName: String!
  fileSize: Int!
  imgKey: String!
  modified: Time!
}

input AddFloorPlanInput {
  image: AddImageInput!
  latitude: Float!
  locationID: ID!
  longitude: Float!
  name: String!
  referencePoint1X: Int!
  referencePoint1Y: Int!
  referencePoint2X: Int!
  referencePoint2Y: Int!
  referenceX: Int!
  referenceY: Int!
  scaleInMeters: Float!
}

input AddFlowDraftInput {
  description: String
  endParamDefinitions: [VariableDefinitionInput!]!
  flowID: ID
  name: String!
}

input AddFormulaInput {
  kpiFk: ID!
  networkTypeFk: ID!
  status: Boolean!
  techFk: ID!
  textFormula: String!
}

input AddHyperlinkInput {
  category: String
  displayName: String
  documentCategoryId: ID
  entityId: ID!
  entityType: ImageEntity!
  url: String!
}

input AddImageInput {
  annotation: String
  category: String
  contentType: String!
  documentCategoryId: ID
  entityId: ID!
  entityType: ImageEntity!
  fileName: String!
  fileSize: Int!
  imgKey: String!
  modified: Time!
}

input AddKpiCategoryInput {
  name: String!
}

input AddKpiInput {
  description: String!
  domainFk: ID!
  kpiCategoryFK: ID!
  name: String!
  status: Boolean!
}

input AddKqiCategoryInput {
  name: String!
}

input AddKqiComparatorInput {
  comparatorFk: ID!
  comparatorType: String!
  kqiTargetFk: ID
  number: Float!
}

input AddKqiInput {
  description: String!
  endDateTime: Time!
  formula: String!
  kqiCategory: ID!
  kqiPerspective: ID!
  kqiSource: ID!
  kqiTemporalFrequency: ID!
  name: String!
  startDateTime: Time!
}

input AddKqiPerspectiveInput {
  name: String!
}

input AddKqiSourceInput {
  name: String!
}

input AddKqiTargetInput {
  allowedVariation: Float!
  endTime: Time!
  impact: String!
  initTime: Time!
  kqi: ID!
  kqiComparator: AddKqiComparatorInput
  name: String!
  period: Float!
  status: Boolean!
}

input AddKqiTemporalFrequencyInput {
  name: String!
}

input AddLinkInput {
  properties: [PropertyInput!]
  serviceIds: [ID!]
  sides: [LinkSide!]!
  workOrder: ID
}

input AddLocationInput {
  externalID: String
  latitude: Float
  longitude: Float
  name: String!
  parent: ID
  properties: [PropertyInput!]
  type: ID!
}

input AddLocationTypeInput {
  documentCategories: [DocumentCategoryInput!]
  isSite: Boolean
  mapType: String
  mapZoomLevel: Int
  name: String!
  properties: [PropertyTypeInput!]
  surveyTemplateCategories: [SurveyTemplateCategoryInput!]
}

input AddNetworkTypeInput {
  name: String!
}

input AddOrganizationInput {
  description: String!
  name: String!
}

input AddParameterInput {
  booleanValue: Boolean
  floatValue: Float
  intValue: Int
  latitudeValue: Float
  longitudeValue: Float
  parameterType: ConfigurationParameterTypeRef!
  previous: ParameterRef
  rangeFromValue: Float
  rangeToValue: Float
  stringValue: String
  versionCM: [CMVersionRef]!
}

type AddParameterPayload {
  numUids: Int
  parameter(filter: ParameterFilter, first: Int, offset: Int, order: ParameterOrder): [Parameter]
}

input AddPermissionsPolicyInput {
  assuranceInput: AssurancePolicyInput
  automationInput: AutomationPolicyInput
  description: String
  groups: [ID!]
  inventoryInput: InventoryPolicyInput
  isGlobal: Boolean
  isMulticontractor: Boolean
  name: String!
  workforceInput: WorkforcePolicyInput
}

input AddProjectInput {
  creatorId: ID
  description: String
  location: ID
  name: String!
  priority: ProjectPriority
  properties: [PropertyInput!]
  type: ID!
}

input AddProjectTypeInput {
  description: String
  name: String!
  properties: [PropertyTypeInput!]
  workOrders: [WorkOrderDefinitionInput!]
}

input AddPropertyTypeValueInput {
  id: ID
  isDeleted: Boolean
  name: String!
  parentPropertyType: [ParentPropertyTypeValueInput]
  parentPropertyTypeValue: [String]
  propertyType: ID
}

input AddRecommendationsCategoryInput {
  name: String!
}

input AddRecommendationsInput {
  alarmType: String!
  command: String
  externalID: String!
  longDescription: String!
  priority: Int!
  recommendationsCategory: ID!
  recommendationsSources: ID!
  resource: String!
  runbook: String
  shortDescription: String!
  status: Boolean!
  used: Int
  userApprobed: ID
  userCreate: ID!
  vendor: ID!
}

input AddRecommendationsListInput {
  recommendations: [AddRecommendationsInput!]!
}

input AddRecommendationsSourcesInput {
  name: String!
}

input AddResourceInput {
  available: Boolean
  belongs_to: ResourceRef
  composed_of: [Composed_ofRef]
  cross_connection: [ResourceRef]
  externalId: Int
  lifecycleStatus: LifecycleStatus
  logical_link: [ResourceRef]
  name: String!
  operationalSubStatus: OperationalSubStatus
  physical_link: ResourceRef
  planningSubStatus: PlanningSubStatus
  typePlanningSubStatus: TypePlanningSubStatus
  usageSubStatus: UsageSubStatus
}

type AddResourcePayload {
  numUids: Int
  resource(filter: ResourceFilter, first: Int, offset: Int, order: ResourceOrder): [Resource]
}

input AddResourcePropertyInput {
  booleanValue: Boolean
  floatValue: Float
  intValue: Int
  latitudeValue: Float
  longitudeValue: Float
  rangeFromValue: Float
  rangeToValue: Float
  rawValue: String
  resource: [ResourceRef]!
  stringValue: String
}

type AddResourcePropertyPayload {
  numUids: Int
  resourceProperty(filter: ResourcePropertyFilter, first: Int, offset: Int, order: ResourcePropertyOrder): [ResourceProperty]
}

input AddResourcePropertyTypeInput {
  booleanValue: Boolean
  category: String
  externalId: String
  floatValue: Float
  id: ID
  index: Int
  intValue: Int
  isDeleted: Boolean
  isEditable: Boolean
  isInstanceProperty: Boolean
  isListable: Boolean
  isMandatory: Boolean
  latitudeValue: Float
  longitudeValue: Float
  name: String!
  nodeType: String
  propertyCategory: ID
  rangeFromValue: Float
  rangeToValue: Float
  rawValue: String
  resourceSpecification: ID
  stringValue: String
  type: ResourcePropertyKind!
}

input AddResourceSpecificationInput {
  name: String!
  quantity: Int
  resourcePropertyTypes: [AddResourcePropertyTypeInput]
  resourceType: ID!
  vendor: ID
}

input AddResourceSpecificationItemsInput {
  resourceSpecification: ID
  resourceSpecificationRelationship: ID!
}

input AddResourceSpecificationRelationshipInput {
  name: String!
  resourceSpecification: ID!
  resourceSpecificationList: [ID]
}

input AddResourceTypeInput {
  name: String!
  resourceTypeBaseType: ResourceTypeBaseTypeKind!
  resourceTypeClass: ResourceTypeClassKind!
}

input AddResourceTypeRelationshipInput {
  locationType: ID
  resourceRelationshipMultiplicity: ResourceRelationshipMultiplicityKind!
  resourceRelationshipType: ResourceRelationshipTypeKind!
  resourceTypeA: ID!
  resourceTypeB: ID
}

input AddRuleInput {
  additionalInfo: String
  endDateTime: Time
  eventSeverity: ID!
  eventTypeName: String
  gracePeriod: Int!
  name: String!
  ruleType: ID!
  specificProblem: String
  startDateTime: Time
  status: Boolean!
  threshold: ID!
}

input AddRuleLimitInput {
  comparator: ID!
  limitType: String!
  number: Int!
  rule: ID!
}

input AddRuleTypeInput {
  name: String!
}

input AddSchedulerConfigInput {
  changeRequest: ChangeRequestRef!
  createTime: DateTime!
  name: String
  rollbackPolicy: RollbackPolicyConfig
  status: SchedulerConfigStatus!
  time: DateTime
  weekDay: WeekDay!
}

type AddSchedulerConfigPayload {
  numUids: Int
  schedulerConfig(filter: SchedulerConfigFilter, first: Int, offset: Int, order: SchedulerConfigOrder): [SchedulerConfig]
}

input AddServiceEndpointInput {
  definition: ID!
  equipmentID: ID!
  id: ID!
  portId: ID
}

input AddTechInput {
  domainFk: ID!
  name: String!
}

input AddThresholdInput {
  description: String!
  kpi: ID!
  name: String!
  status: Boolean!
}

input AddUsersGroupInput {
  description: String
  members: [ID!]
  name: String!
  policies: [ID!]
}

input AddVendorInput {
  name: String!
}

input AddWorkOrderInput {
  assigneeId: ID
  checkList: [CheckListItemInput!]
  checkListCategories: [CheckListCategoryInput!]
  description: String
  dueDate: Time
  duration: Float
  flowInstanceId: ID
  index: Int
  isNameEditable: Boolean
  locationId: ID
  name: String!
  organizationFk: ID
  ownerId: ID
  priority: WorkOrderPriority
  projectId: ID
  properties: [PropertyInput!]
  scheduledAt: Time
  status: WorkOrderStatus
  workOrderTypeId: ID!
}

input AddWorkOrderTypeInput {
  assigneeCanCompleteWorkOrder: Boolean
  checkListCategories: [CheckListCategoryDefinitionInput!]
  description: String
  duration: Float
  name: String!
  properties: [PropertyTypeInput]
}

input AddWorkerTypeInput {
  description: String
  name: String!
  propertyTypes: [PropertyTypeInput!]
}

type AdministrativePolicy {
  access: BasicPermissionRule!
}

type AlarmFilter implements Node {
  alarmStatus: AlarmStatus
  beginTime: Time!
  creationTime: Time!
  enable: Boolean!
  endTime: Time!
  id: ID!
  name: String!
  networkResource: String!
  reason: String!
  user: String!
}

"""A connection to a list of AlarmFilter."""
type AlarmFilterConnection {
  """A list of AlarmFilter edges."""
  edges: [AlarmFilterEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total AlarmFilter of projects in all pages."""
  totalCount: Int!
}

"""A AlarmFilter edge in a connection."""
type AlarmFilterEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The AlarmFilter at the end of the edge."""
  node: AlarmFilter
}

input AlarmFilterFilterInput {
  filterType: AlarmFilterFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum AlarmFilterFilterType {
  NAME
}

input AlarmFilterInput {
  beginTime: Time!
  creationTime: Time!
  enable: Boolean!
  endTime: Time!
  name: String!
  networkResource: String!
  reason: String!
  user: String!
}

"""Ordering options for AlarmFilter connections."""
input AlarmFilterOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order AlarmFilter by."""
  field: AlarmFilterOrderField
}

"""Properties by which AlarmFilter connections can be ordered."""
enum AlarmFilterOrderField {
  """Order AlarmFilter by creation time."""
  CREATED_AT

  """Order AlarmFilter by name."""
  NAME

  """Order AlarmFilter by update time."""
  UPDATED_AT
}

type AlarmStatus implements Node {
  AlarmFilter: [AlarmFilter!]
  id: ID!
  name: String!
}

"""A connection to a list of alarmStatus."""
type AlarmStatusConnection {
  """A list of alarmStatus edges."""
  edges: [AlarmStatusEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total alarmStatus of projects in all pages."""
  totalCount: Int!
}

"""A alarmStatus edge in a connection."""
type AlarmStatusEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The alarmStatus at the end of the edge."""
  node: AlarmStatus
}

input AlarmStatusFilterInput {
  filterType: AlarmStatusFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum AlarmStatusFilterType {
  NAME
}

input AlarmStatusInput {
  id: ID!
  name: String!
}

"""Ordering options for alarmStatus connections."""
input AlarmStatusOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order alarmStatus by."""
  field: AlarmStatusOrderField
}

"""Properties by which alarmStatus connections can be ordered."""
enum AlarmStatusOrderField {
  """Order alarmStatus by creation time."""
  CREATED_AT

  """Order alarmStatus by name."""
  NAME

  """Order alarmStatus by update time."""
  UPDATED_AT
}

type Appointment implements Node {
  assignee: User!
  creationDate: Time!
  duration: Float!
  end: Time!
  id: ID!
  start: Time!
  status: AppointmentStatus!
  workOrder: WorkOrder!
}

"""A connection to a list of appoinments."""
type AppointmentConnection {
  """A list of project edges."""
  edges: [AppointmentEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of appoinments in all pages."""
  totalCount: Int!
}

"""A project edge in a connection."""
type AppointmentEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The project at the end of the edge."""
  node: Appointment
}

"""Ordering options for project connections."""
input AppointmentOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order appoinments by."""
  field: AppointmentOrderField
}

"""Properties by which project connections can be ordered."""
enum AppointmentOrderField {
  """Order appoinments by creation time."""
  CREATED_AT

  """Order appoinments by date."""
  DATE

  """Order appoinments by update time."""
  UPDATED_AT
}

"""Appointment Status"""
enum AppointmentStatus {
  ACTIVE
  CANCELED
}

input ArchiveFlowInput {
  flowID: ID!
}

type AssurancePolicy {
  read: BasicPermissionRule!
  templates: CUD!
}

input AssurancePolicyInput {
  read: BasicPermissionRuleInput
  templates: BasicCUDInput
}

input AuthRule {
  and: [AuthRule]
  not: AuthRule
  or: [AuthRule]
  rule: String
}

enum AuthType {
  BASIC
  ODIC
}

type AutomationActivity implements Node {
  activityType: AutomationActivityField!
  author: User
  blockInstance: BlockInstance
  createTime: Time!
  entityType: AutomationEntityType!
  flowInstance: FlowInstance
  id: ID!
  newValue: String
  oldValue: String
}

enum AutomationActivityField {
  CREATION_DATE
  STATUS
}

input AutomationActivityFilterInput {
  activityType: AutomationActivityField!
  limit: Int!
  orderDirection: OrderDirection!
}

enum AutomationEntityType {
  CREATION_DATE
  STATUS
}

type AutomationPolicy {
  read: BasicPermissionRule!
  templates: CUD!
}

input AutomationPolicyInput {
  read: BasicPermissionRuleInput
  templates: BasicCUDInput
}

input BaseBlockInput {
  backoffRate: Int
  enableErrorHandling: Boolean
  enableInputStateTransformation: Boolean!
  enableInputTransformation: Boolean!
  enableOutputStateTransformation: Boolean!
  enableOutputTransformation: Boolean!
  enableRetryPolicy: Boolean
  inputParamDefinitions: String
  inputStateParamDefinitions: String
  inputStateTransfStrategy: TransfStrategy
  inputTransfStrategy: TransfStrategy
  maxAttemps: Int
  outputParamDefinitions: String
  outputStateParamDefinitions: String
  outputStateTransfStrategy: TransfStrategy
  outputTransfStrategy: TransfStrategy
  retryInterval: Int
  units: RetryUnit
}

input BasicCUDInput {
  create: BasicPermissionRuleInput
  delete: BasicPermissionRuleInput
  update: BasicPermissionRuleInput
}

type BasicPermissionRule {
  isAllowed: PermissionValue!
}

input BasicPermissionRuleInput {
  isAllowed: PermissionValue!
}

type Block implements Node {
  backoffRate: Int
  cid: String!
  details: BlockDetails!
  enableErrorHandling: Boolean
  enableInputStateTransformation: Boolean!
  enableInputTransformation: Boolean!
  enableOutputStateTransformation: Boolean!
  enableOutputTransformation: Boolean!
  enableRetryPolicy: Boolean
  id: ID!
  inputParamDefinitions: [VariableDefinition!]!
  inputStateTransfStrategy: TransfStrategy
  inputStateTransformation: String
  inputTransfStrategy: TransfStrategy
  inputTransformation: String
  instances: [BlockInstance!]
  maxAttemps: Int
  nextBlocks: [Block!]!
  outputParamDefinitions: [VariableDefinition!]!
  outputStateTransfStrategy: TransfStrategy
  outputStateTransformation: String
  outputTransfStrategy: TransfStrategy
  outputTransformation: String
  prevBlocks: [Block!]!
  retryInterval: Int
  uiRepresentation: BlockUIRepresentation
  units: RetryUnit
}

union BlockDetails = ActionBlock | ChoiceBlock | EndBlock | ExecuteFlowBlock | ForEachBlock | GotoBlock | InvokeRestAPIBlock | KafkaBlock | ParallelBlock | StartBlock | TimerBlock | TriggerBlock | WaitForSignalBlock

type BlockInstance implements Node {
  activities(filter: AutomationActivityFilterInput): [AutomationActivity!]!
  block: Block!
  endDate: Time
  failure_reason: String
  id: ID!
  inputs: [VariableValue!]!
  outputs: [VariableValue!]!
  startDate: Time!
  status: BlockInstanceStatus!
}

enum BlockInstanceStatus {
  COMPLETED
  FAILED
  IN_PROGRESS
  PENDING
  WAITING
}

type BlockUIRepresentation {
  name: String!
  xPosition: Int!
  yPosition: Int!
}

input BlockUIRepresentationInput {
  name: String!
  xPosition: Int!
  yPosition: Int!
}

type BlockVariable {
  block: Block!
  checkListItemDefinition: CheckListItemDefinition
  inputPropertyTypeDefinition: PropertyType
  inputVariableDefinition: VariableDefinition
  type: VariableExpressionType!
}

input BlockVariableInput {
  blockCid: String!
  checkListItemDefinitionId: Int
  propertyTypeId: Int
  type: VariableExpressionType!
  variableDefinitionKey: String
}

type CMVersion {
  id: ID!
  parameters(filter: ParameterFilter, first: Int, offset: Int, order: ParameterOrder): [Parameter!]!
  parametersAggregate(filter: ParameterFilter): ParameterAggregateResult
  previous(filter: CMVersionFilter): CMVersion
  status: VersionStatus!
  validFrom: DateTime
  validTo: DateTime
}

type CMVersionAggregateResult {
  count: Int
  validFromMax: DateTime
  validFromMin: DateTime
  validToMax: DateTime
  validToMin: DateTime
}

input CMVersionFilter {
  and: [CMVersionFilter]
  has: [CMVersionHasFilter]
  id: [ID!]
  not: CMVersionFilter
  or: [CMVersionFilter]
}

enum CMVersionHasFilter {
  parameters
  previous
  status
  validFrom
  validTo
}

input CMVersionOrder {
  asc: CMVersionOrderable
  desc: CMVersionOrderable
  then: CMVersionOrder
}

enum CMVersionOrderable {
  validFrom
  validTo
}

input CMVersionPatch {
  parameters: [ParameterRef!]
  previous: CMVersionRef
  status: VersionStatus
  validFrom: DateTime
  validTo: DateTime
}

input CMVersionRef {
  id: ID
  parameters: [ParameterRef!]
  previous: CMVersionRef
  status: VersionStatus
  validFrom: DateTime
  validTo: DateTime
}

type CUD {
  create: BasicPermissionRule!
  delete: BasicPermissionRule!
  update: BasicPermissionRule!
}

enum CellularNetworkType {
  CDMA
  GSM
  LTE
  WCDMA
}

type ChangeItem {
  booleanValue: Boolean
  floatValue: Float
  id: ID!
  intValue: Int
  latitudeValue: Float
  longitudeValue: Float
  parameterType(filter: ConfigurationParameterTypeFilter): ConfigurationParameterType!
  rangeFromValue: Float
  rangeToValue: Float
  resource(filter: ResourceFilter): Resource
  status: ChangeItemStatus!
  stringValue: String
}

type ChangeItemAggregateResult {
  count: Int
  floatValueAvg: Float
  floatValueMax: Float
  floatValueMin: Float
  floatValueSum: Float
  intValueAvg: Float
  intValueMax: Int
  intValueMin: Int
  intValueSum: Int
  latitudeValueAvg: Float
  latitudeValueMax: Float
  latitudeValueMin: Float
  latitudeValueSum: Float
  longitudeValueAvg: Float
  longitudeValueMax: Float
  longitudeValueMin: Float
  longitudeValueSum: Float
  rangeFromValueAvg: Float
  rangeFromValueMax: Float
  rangeFromValueMin: Float
  rangeFromValueSum: Float
  rangeToValueAvg: Float
  rangeToValueMax: Float
  rangeToValueMin: Float
  rangeToValueSum: Float
  stringValueMax: String
  stringValueMin: String
}

input ChangeItemFilter {
  and: [ChangeItemFilter]
  has: [ChangeItemHasFilter]
  id: [ID!]
  not: ChangeItemFilter
  or: [ChangeItemFilter]
}

enum ChangeItemHasFilter {
  booleanValue
  floatValue
  intValue
  latitudeValue
  longitudeValue
  parameterType
  rangeFromValue
  rangeToValue
  resource
  status
  stringValue
}

input ChangeItemOrder {
  asc: ChangeItemOrderable
  desc: ChangeItemOrderable
  then: ChangeItemOrder
}

enum ChangeItemOrderable {
  floatValue
  intValue
  latitudeValue
  longitudeValue
  rangeFromValue
  rangeToValue
  stringValue
}

input ChangeItemPatch {
  booleanValue: Boolean
  floatValue: Float
  intValue: Int
  latitudeValue: Float
  longitudeValue: Float
  parameterType: ConfigurationParameterTypeRef
  rangeFromValue: Float
  rangeToValue: Float
  resource: ResourceRef
  status: ChangeItemStatus
  stringValue: String
}

input ChangeItemRef {
  booleanValue: Boolean
  floatValue: Float
  id: ID
  intValue: Int
  latitudeValue: Float
  longitudeValue: Float
  parameterType: ConfigurationParameterTypeRef
  rangeFromValue: Float
  rangeToValue: Float
  resource: ResourceRef
  status: ChangeItemStatus
  stringValue: String
}

enum ChangeItemStatus {
  CANCELLED
  FAILED
  IN_EXECUTION
  PENDING
  SUCCESSFUL
}

type ChangeRequest {
  activities(filter: ChangeRequestActivityFilter, first: Int, offset: Int, order: ChangeRequestActivityOrder): [ChangeRequestActivity]
  activitiesAggregate(filter: ChangeRequestActivityFilter): ChangeRequestActivityAggregateResult
  description: String!
  id: ID!
  items(filter: ChangeItemFilter, first: Int, offset: Int, order: ChangeItemOrder): [ChangeItem!]!
  itemsAggregate(filter: ChangeItemFilter): ChangeItemAggregateResult
  scheduler(filter: SchedulerConfigFilter): SchedulerConfig
  source: ChangeRequestSource
  status: ChangeRequestStatus!
  type: ChangeRequestType
}

type ChangeRequestActivity {
  activityType: ChangeRequestActivityField!
  changeRequest(filter: ChangeRequestFilter): ChangeRequest!
  createTime: DateTime!
  id: ID!
  isCreate: Boolean!
  newValue: String
  oldValue: String
}

type ChangeRequestActivityAggregateResult {
  count: Int
  createTimeMax: DateTime
  createTimeMin: DateTime
  newValueMax: String
  newValueMin: String
  oldValueMax: String
  oldValueMin: String
}

enum ChangeRequestActivityField {
  CREATION_DATE
  DESCRIPTION
  NAME
  PRIORITY
  REQUESTER
  STATUS
}

input ChangeRequestActivityFilter {
  and: [ChangeRequestActivityFilter]
  has: [ChangeRequestActivityHasFilter]
  id: [ID!]
  not: ChangeRequestActivityFilter
  or: [ChangeRequestActivityFilter]
}

enum ChangeRequestActivityHasFilter {
  activityType
  changeRequest
  createTime
  isCreate
  newValue
  oldValue
}

input ChangeRequestActivityOrder {
  asc: ChangeRequestActivityOrderable
  desc: ChangeRequestActivityOrderable
  then: ChangeRequestActivityOrder
}

enum ChangeRequestActivityOrderable {
  createTime
  newValue
  oldValue
}

input ChangeRequestActivityPatch {
  activityType: ChangeRequestActivityField
  changeRequest: ChangeRequestRef
  createTime: DateTime
  isCreate: Boolean
  newValue: String
  oldValue: String
}

input ChangeRequestActivityRef {
  activityType: ChangeRequestActivityField
  changeRequest: ChangeRequestRef
  createTime: DateTime
  id: ID
  isCreate: Boolean
  newValue: String
  oldValue: String
}

type ChangeRequestAggregateResult {
  count: Int
  descriptionMax: String
  descriptionMin: String
}

input ChangeRequestFilter {
  and: [ChangeRequestFilter]
  has: [ChangeRequestHasFilter]
  id: [ID!]
  not: ChangeRequestFilter
  or: [ChangeRequestFilter]
}

enum ChangeRequestHasFilter {
  activities
  description
  items
  scheduler
  source
  status
  type
}

input ChangeRequestOrder {
  asc: ChangeRequestOrderable
  desc: ChangeRequestOrderable
  then: ChangeRequestOrder
}

enum ChangeRequestOrderable {
  description
}

input ChangeRequestPatch {
  activities: [ChangeRequestActivityRef]
  description: String
  items: [ChangeItemRef!]
  scheduler: SchedulerConfigRef
  source: ChangeRequestSource
  status: ChangeRequestStatus
  type: ChangeRequestType
}

input ChangeRequestRef {
  activities: [ChangeRequestActivityRef]
  description: String
  id: ID
  items: [ChangeItemRef!]
  scheduler: SchedulerConfigRef
  source: ChangeRequestSource
  status: ChangeRequestStatus
  type: ChangeRequestType
}

enum ChangeRequestSource {
  GUI
  NON_RT_RIC
  NSSMF
  WORKFLOW
}

enum ChangeRequestStatus {
  APPROVAL
  CANCELLED
  FAILED
  IN_EXECUTION
  PENDING
  REJECTED
  SCHEDULED
  SUBMITTED
  SUCCESSFUL
  SUCCESSFUL_WITH_WARNINGS
}

enum ChangeRequestType {
  AUTOMATIC
  MANUAL
}

type CheckListCategory implements Node {
  checkList: [CheckListItem!]!
  description: String
  id: ID!
  title: String!
}

type CheckListCategoryDefinition {
  checklistItemDefinitions: [CheckListItemDefinition!]!
  description: String
  id: ID!
  title: String!
}

input CheckListCategoryDefinitionInput {
  checkList: [CheckListDefinitionInput!]!
  description: String
  id: ID
  title: String!
}

input CheckListCategoryInput {
  checkList: [CheckListItemInput!]
  description: String
  id: ID
  title: String!
}

input CheckListDefinitionInput {
  enumSelectionMode: CheckListItemEnumSelectionMode
  enumValues: String
  helpText: String
  id: ID
  index: Int
  isMandatory: Boolean
  title: String!
  type: CheckListItemType!
}

type CheckListItem implements Node {
  cellData: [SurveyCellScan!]
  checked: Boolean
  enumSelectionMode: CheckListItemEnumSelectionMode
  enumValues: String
  files: [File!]
  helpText: String
  id: ID!
  index: Int
  isMandatory: Boolean
  selectedEnumValues: String
  stringValue: String
  title: String!
  type: CheckListItemType!
  wifiData: [SurveyWiFiScan!]
  yesNoResponse: YesNoResponse
}

type CheckListItemDefinition {
  enumSelectionMode: CheckListItemEnumSelectionMode
  enumValues: String
  helpText: String
  id: ID!
  index: Int
  isMandatory: Boolean
  title: String!
  type: CheckListItemType!
}

enum CheckListItemEnumSelectionMode {
  multiple
  single
}

input CheckListItemInput {
  cellData: [SurveyCellScanData!]
  checked: Boolean
  enumSelectionMode: CheckListItemEnumSelectionMode
  enumValues: String
  files: [FileInput!]
  helpText: String
  id: ID
  index: Int
  isMandatory: Boolean
  selectedEnumValues: String
  stringValue: String
  title: String!
  type: CheckListItemType!
  wifiData: [SurveyWiFiScanData!]
  yesNoResponse: YesNoResponse
}

enum CheckListItemType {
  cell_scan
  enum
  files
  simple
  string
  wifi_scan
  yes_no
}

type ChoiceBlock {
  defaultExitPoint: ExitPoint!
  entryPoint: EntryPoint!
  rules: [DecisionRoute!]!
}

input ChoiceBlockInput {
  basicDefinitions: BaseBlockInput!
  cid: String!
  defaultExitPoint: ExitPointInput
  entryPoint: EntryPointInput
  routes: [DecisionRouteInput!]
  uiRepresentation: BlockUIRepresentationInput
}

type ClockActivity {
  author: User!
  details: ClockDetails!
  time: Time!
}

type ClockDetails {
  clockOutReason: ClockOutReason
  comment: String
  distanceMeters: Float
}

enum ClockOutReason {
  BLOCKED
  PAUSE
  SUBMIT
  SUBMIT_INCOMPLETE
}

type Comment implements Node {
  author: User!
  createTime: Time!
  id: ID!
  text: String!
}

enum CommentEntity {
  PROJECT
  WORK_ORDER
}

input CommentInput {
  entityType: CommentEntity!
  id: ID!
  text: String!
}

type Comparator implements Node {
  id: ID!
  name: String!
  ruleLimit: [RuleLimit!]
}

"""A connection to a list of comparator."""
type ComparatorConnection {
  """A list of comparator edges."""
  edges: [ComparatorEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total comparator of projects in all pages."""
  totalCount: Int!
}

"""A comparator edge in a connection."""
type ComparatorEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The comparator at the end of the edge."""
  node: Comparator
}

input ComparatorFilterInput {
  filterType: ComparatorFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum ComparatorFilterType {
  NAME
}

"""Ordering options for comparator connections."""
input ComparatorOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order comparator by."""
  field: ComparatorOrderField
}

"""Properties by which comparator connections can be ordered."""
enum ComparatorOrderField {
  """Order comparator by creation time."""
  CREATED_AT

  """Order comparator by name."""
  NAME

  """Order comparator by update time."""
  UPDATED_AT
}

type Composed_of {
  resource(filter: ResourceFilter): Resource
}

type Composed_ofAggregateResult {
  count: Int
}

input Composed_ofFilter {
  and: [Composed_ofFilter]
  has: [Composed_ofHasFilter]
  not: Composed_ofFilter
  or: [Composed_ofFilter]
}

enum Composed_ofHasFilter {
  resource
}

input Composed_ofPatch {
  resource: ResourceRef
}

input Composed_ofRef {
  resource: ResourceRef
}

type ConfigParamTag {
  id: ID!
  name: String!
  parameters(filter: ConfigurationParameterTypeFilter, first: Int, offset: Int, order: ConfigurationParameterTypeOrder): [ConfigurationParameterType]!
  parametersAggregate(filter: ConfigurationParameterTypeFilter): ConfigurationParameterTypeAggregateResult
}

type ConfigParamTagAggregateResult {
  count: Int
  nameMax: String
  nameMin: String
}

input ConfigParamTagFilter {
  and: [ConfigParamTagFilter]
  has: [ConfigParamTagHasFilter]
  id: [ID!]
  not: ConfigParamTagFilter
  or: [ConfigParamTagFilter]
}

enum ConfigParamTagHasFilter {
  name
  parameters
}

input ConfigParamTagOrder {
  asc: ConfigParamTagOrderable
  desc: ConfigParamTagOrderable
  then: ConfigParamTagOrder
}

enum ConfigParamTagOrderable {
  name
}

input ConfigParamTagPatch {
  name: String
  parameters: [ConfigurationParameterTypeRef]
}

input ConfigParamTagRef {
  id: ID
  name: String
  parameters: [ConfigurationParameterTypeRef]
}

type ConfigurationParameterType {
  booleanValue: Boolean
  category: String
  externalId: String
  floatValue: Float
  id: ID!
  index: Int
  intValue: Int
  isDeleted: Boolean
  isEditable: Boolean
  isListable: Boolean
  isMandatory: Boolean
  isPrioritary: Boolean
  latitudeValue: Float
  longitudeValue: Float
  mappingIn: String
  mappingOut: String
  name: String!
  nodeType: String
  parameters(filter: ParameterFilter, first: Int, offset: Int, order: ParameterOrder): [Parameter!]
  parametersAggregate(filter: ParameterFilter): ParameterAggregateResult
  rangeFromValue: Float
  rangeToValue: Float
  rawValue: String
  stringValue: String
  tags(filter: ConfigParamTagFilter, first: Int, offset: Int, order: ConfigParamTagOrder): [ConfigParamTag!]
  tagsAggregate(filter: ConfigParamTagFilter): ConfigParamTagAggregateResult
  type: ParameterKind!
}

type ConfigurationParameterTypeAggregateResult {
  categoryMax: String
  categoryMin: String
  count: Int
  externalIdMax: String
  externalIdMin: String
  floatValueAvg: Float
  floatValueMax: Float
  floatValueMin: Float
  floatValueSum: Float
  indexAvg: Float
  indexMax: Int
  indexMin: Int
  indexSum: Int
  intValueAvg: Float
  intValueMax: Int
  intValueMin: Int
  intValueSum: Int
  latitudeValueAvg: Float
  latitudeValueMax: Float
  latitudeValueMin: Float
  latitudeValueSum: Float
  longitudeValueAvg: Float
  longitudeValueMax: Float
  longitudeValueMin: Float
  longitudeValueSum: Float
  mappingInMax: String
  mappingInMin: String
  mappingOutMax: String
  mappingOutMin: String
  nameMax: String
  nameMin: String
  nodeTypeMax: String
  nodeTypeMin: String
  rangeFromValueAvg: Float
  rangeFromValueMax: Float
  rangeFromValueMin: Float
  rangeFromValueSum: Float
  rangeToValueAvg: Float
  rangeToValueMax: Float
  rangeToValueMin: Float
  rangeToValueSum: Float
  rawValueMax: String
  rawValueMin: String
  stringValueMax: String
  stringValueMin: String
}

input ConfigurationParameterTypeFilter {
  and: [ConfigurationParameterTypeFilter]
  has: [ConfigurationParameterTypeHasFilter]
  id: [ID!]
  not: ConfigurationParameterTypeFilter
  or: [ConfigurationParameterTypeFilter]
}

enum ConfigurationParameterTypeHasFilter {
  booleanValue
  category
  externalId
  floatValue
  index
  intValue
  isDeleted
  isEditable
  isListable
  isMandatory
  isPrioritary
  latitudeValue
  longitudeValue
  mappingIn
  mappingOut
  name
  nodeType
  parameters
  rangeFromValue
  rangeToValue
  rawValue
  stringValue
  tags
  type
}

input ConfigurationParameterTypeOrder {
  asc: ConfigurationParameterTypeOrderable
  desc: ConfigurationParameterTypeOrderable
  then: ConfigurationParameterTypeOrder
}

enum ConfigurationParameterTypeOrderable {
  category
  externalId
  floatValue
  index
  intValue
  latitudeValue
  longitudeValue
  mappingIn
  mappingOut
  name
  nodeType
  rangeFromValue
  rangeToValue
  rawValue
  stringValue
}

input ConfigurationParameterTypePatch {
  booleanValue: Boolean
  category: String
  externalId: String
  floatValue: Float
  index: Int
  intValue: Int
  isDeleted: Boolean
  isEditable: Boolean
  isListable: Boolean
  isMandatory: Boolean
  isPrioritary: Boolean
  latitudeValue: Float
  longitudeValue: Float
  mappingIn: String
  mappingOut: String
  name: String
  nodeType: String
  parameters: [ParameterRef!]
  rangeFromValue: Float
  rangeToValue: Float
  rawValue: String
  stringValue: String
  tags: [ConfigParamTagRef!]
  type: ParameterKind
}

input ConfigurationParameterTypeRef {
  booleanValue: Boolean
  category: String
  externalId: String
  floatValue: Float
  id: ID
  index: Int
  intValue: Int
  isDeleted: Boolean
  isEditable: Boolean
  isListable: Boolean
  isMandatory: Boolean
  isPrioritary: Boolean
  latitudeValue: Float
  longitudeValue: Float
  mappingIn: String
  mappingOut: String
  name: String
  nodeType: String
  parameters: [ParameterRef!]
  rangeFromValue: Float
  rangeToValue: Float
  rawValue: String
  stringValue: String
  tags: [ConfigParamTagRef!]
  type: ParameterKind
}

type Connector {
  source: ExitPoint!
  target: EntryPoint!
}

input ConnectorInput {
  sourceBlockCid: String!
  sourcePoint: ExitPointInput
  targetBlockCid: String!
  targetPoint: EntryPointInput
}

input ContainsFilter {
  point: PointRef
  polygon: PolygonRef
}

type Coordinates {
  latitude: Float!
  longitude: Float!
}

type Counter implements Node {
  counterFamily: CounterFamily
  counterformula: [CounterFormula]!
  externalID: String!
  id: ID!
  name: String!
  networkManagerSystem: String!
  vendorFk: Vendor!
}

"""A connection to a list of counters."""
type CounterConnection {
  """A list of counters edges."""
  edges: [CounterEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total counters of projects in all pages."""
  totalCount: Int!
}

"""A counters edge in a connection."""
type CounterEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The counters at the end of the edge."""
  node: Counter
}

type CounterFamily implements Node {
  id: ID!
  name: String!
}

"""A connection to a list of counterFamilies."""
type CounterFamilyConnection {
  """A list of counterFamilies edges."""
  edges: [CounterFamilyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total counterFamilies of projects in all pages."""
  totalCount: Int!
}

"""A counterFamilies edge in a connection."""
type CounterFamilyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The counterFamilies at the end of the edge."""
  node: CounterFamily
}

input CounterFamilyFilterInput {
  filterType: CounterFamilyFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum CounterFamilyFilterType {
  NAME
}

input CounterFamilyInput {
  name: String!
}

"""Ordering options for counterFamilies connections."""
input CounterFamilyOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order counterFamilies by."""
  field: CounterFamilyOrderField
}

"""Properties by which counterFamilies connections can be ordered."""
enum CounterFamilyOrderField {
  """Order counterFamilies by creation time."""
  CREATED_AT

  """Order counterFamilies by name."""
  NAME

  """Order counterFamilies by update time."""
  UPDATED_AT
}

input CounterFilterInput {
  filterType: CounterFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  propertyValue: CounterFamilyInput
  stringSet: [String!]
  stringValue: String
}

enum CounterFilterType {
  COUNTERFAMILY
  EXTERNALID
  NAME
  NETWORKMANAGERSYSTEM
  VENDORFK
}

type CounterFormula implements Node {
  counterFk: Counter!
  formulaFk: Formula!
  id: ID!
  mandatory: Boolean!
}

input CounterListInput {
  counterFk: ID!
  mandatory: Boolean!
}

"""Ordering options for counters connections."""
input CounterOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order counters by."""
  field: CounterOrderField
}

"""Properties by which counters connections can be ordered."""
enum CounterOrderField {
  """Order counters by creation time."""
  CREATED_AT

  """Order counters by name."""
  NAME

  """Order counters by update time."""
  UPDATED_AT
}

"""Position within a pagination."""
scalar Cursor

input CustomHTTP {
  body: String
  forwardHeaders: [String!]
  graphql: String
  introspectionHeaders: [String!]
  method: HTTPMethod!
  mode: Mode
  secretHeaders: [String!]
  skipIntrospection: Boolean
  url: String!
}

type Customer implements Node {
  externalId: String
  id: ID!
  name: String!
}

"""A connection to a list of customers."""
type CustomerConnection {
  """A list of customer edges."""
  edges: [CustomerEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of customers in all pages."""
  totalCount: Int!
}

"""A customer edge in a connection."""
type CustomerEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The customer at the end of the edge."""
  node: Customer
}

scalar DateTime

input DateTimeFilter {
  between: DateTimeRange
  eq: DateTime
  ge: DateTime
  gt: DateTime
  in: [DateTime]
  le: DateTime
  lt: DateTime
}

input DateTimeRange {
  max: DateTime!
  min: DateTime!
}

type DecisionBlock {
  defaultExitPoint: ExitPoint!
  entryPoint: EntryPoint!
  routes: [DecisionRoute!]!
}

input DecisionBlockInput {
  cid: String!
  routes: [DecisionRouteInput!]
  uiRepresentation: BlockUIRepresentationInput
}

type DecisionRoute {
  exitPoint: ExitPoint
}

input DecisionRouteInput {
  cid: String
  condition: VariableExpressionInput!
  index: Int
}

type DeleteCMVersionPayload {
  cMVersion(filter: CMVersionFilter, first: Int, offset: Int, order: CMVersionOrder): [CMVersion]
  msg: String
  numUids: Int
}

type DeleteChangeItemPayload {
  changeItem(filter: ChangeItemFilter, first: Int, offset: Int, order: ChangeItemOrder): [ChangeItem]
  msg: String
  numUids: Int
}

type DeleteChangeRequestActivityPayload {
  changeRequestActivity(filter: ChangeRequestActivityFilter, first: Int, offset: Int, order: ChangeRequestActivityOrder): [ChangeRequestActivity]
  msg: String
  numUids: Int
}

type DeleteChangeRequestPayload {
  changeRequest(filter: ChangeRequestFilter, first: Int, offset: Int, order: ChangeRequestOrder): [ChangeRequest]
  msg: String
  numUids: Int
}

type DeleteComposed_ofPayload {
  composed_of(filter: Composed_ofFilter, first: Int, offset: Int): [Composed_of]
  msg: String
  numUids: Int
}

type DeleteConfigParamTagPayload {
  configParamTag(filter: ConfigParamTagFilter, first: Int, offset: Int, order: ConfigParamTagOrder): [ConfigParamTag]
  msg: String
  numUids: Int
}

type DeleteConfigurationParameterTypePayload {
  configurationParameterType(filter: ConfigurationParameterTypeFilter, first: Int, offset: Int, order: ConfigurationParameterTypeOrder): [ConfigurationParameterType]
  msg: String
  numUids: Int
}

type DeleteParameterPayload {
  msg: String
  numUids: Int
  parameter(filter: ParameterFilter, first: Int, offset: Int, order: ParameterOrder): [Parameter]
}

type DeleteResourcePayload {
  msg: String
  numUids: Int
  resource(filter: ResourceFilter, first: Int, offset: Int, order: ResourceOrder): [Resource]
}

type DeleteResourcePropertyPayload {
  msg: String
  numUids: Int
  resourceProperty(filter: ResourcePropertyFilter, first: Int, offset: Int, order: ResourcePropertyOrder): [ResourceProperty]
}

type DeleteSchedulerConfigPayload {
  msg: String
  numUids: Int
  schedulerConfig(filter: SchedulerConfigFilter, first: Int, offset: Int, order: SchedulerConfigOrder): [SchedulerConfig]
}

input DgraphDefault {
  value: String
}

enum DgraphIndex {
  bool
  day
  exact
  float
  fulltext
  geo
  hash
  hour
  int
  int64
  month
  regexp
  term
  trigram
  year
}

enum DiscoveryMethod {
  INVENTORY
  MANUAL
}

enum DistanceUnit {
  KILOMETER
  MILE
}

type DocumentCategory implements Node {
  files: [File]!
  filesByEntity(entity: ImageEntity!, entityID: ID): [File]!
  hyperlinks: [Hyperlink]!
  hyperlinksByEntity(entity: ImageEntity!, entityID: ID): [Hyperlink]!
  id: ID!
  index: Int
  name: String
  numberOfDocuments: Int!
}

type DocumentCategoryCUD {
  create: DocumentCategoryPermissionRule
  delete: DocumentCategoryPermissionRule
  locationTypeID: Int
  read: DocumentCategoryPermissionRule
  update: DocumentCategoryPermissionRule
}

input DocumentCategoryCUDInput {
  create: DocumentCategoryPermissionRuleInput
  delete: DocumentCategoryPermissionRuleInput
  locationTypeID: Int
  read: DocumentCategoryPermissionRuleInput
  update: DocumentCategoryPermissionRuleInput
}

type DocumentCategoryConnection {
  edges: [DocumentCategoryEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type DocumentCategoryEdge {
  cursor: Cursor!
  node: DocumentCategory
}

input DocumentCategoryInput {
  id: ID
  index: Int!
  name: String!
}

type DocumentCategoryPermissionRule {
  documentCategoryIds: [ID!]
  isAllowed: PermissionValue!
}

input DocumentCategoryPermissionRuleInput {
  documentCategoryIds: [ID!]
  isAllowed: PermissionValue!
}

type Domain implements Node {
  id: ID!
  name: String!
}

"""A connection to a list of domains."""
type DomainConnection {
  """A list of domains edges."""
  edges: [DomainEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total domains of projects in all pages."""
  totalCount: Int!
}

"""A domains edge in a connection."""
type DomainEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The domains at the end of the edge."""
  node: Domain
}

input DomainFilterInput {
  filterType: DomainFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum DomainFilterType {
  NAME
}

input DomainInput {
  id: ID!
  name: String!
}

"""Ordering options for domains connections."""
input DomainOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order domains by."""
  field: DomainOrderField
}

"""Properties by which domains connections can be ordered."""
enum DomainOrderField {
  """Order domains by creation time."""
  CREATED_AT

  """Order domains by name."""
  NAME

  """Order domains by update time."""
  UPDATED_AT
}

input DuplicateFlowInput {
  description: String
  flowID: ID!
  name: String!
}

type Edge {
  ids: [ID!]!
  name: String!
  type: String!
}

input EditAlarmFilterInput {
  alarmStatus: ID
  beginTime: Time!
  enable: Boolean!
  endTime: Time!
  id: ID!
  name: String!
  networkResource: String!
  reason: String!
}

input EditAlarmStatusInput {
  id: ID!
  name: String!
}

input EditAppointmentInput {
  assigneeID: ID
  date: Time
  duration: Float
  id: ID!
  status: AppointmentStatus
  workorderID: ID
}

input EditBlockInput {
  id: ID!
  uiRepresentation: BlockUIRepresentationInput
}

input EditBlockInstanceInput {
  endDate: Time
  failure_reason: String
  id: ID!
  inputJSON: String
  inputs: [VariableValueInput!]
  outputJSON: String
  outputs: [VariableValueInput!]
  status: BlockInstanceStatus
}

input EditComparatorInput {
  id: ID!
  name: String!
}

input EditCounterFamilyInput {
  id: ID!
  name: String!
}

input EditCounterFormulaInput {
  counterFk: ID!
  formulaFk: ID!
  id: ID!
  mandatory: Boolean!
}

input EditCounterInput {
  externalID: String!
  id: ID!
  name: String!
  networkManagerSystem: String!
  vendorFk: ID!
}

input EditDomainInput {
  id: ID!
  name: String!
}

input EditEquipmentInput {
  deviceID: String
  externalId: String
  id: ID!
  name: String!
  properties: [PropertyInput!]
}

input EditEquipmentPortInput {
  properties: [PropertyInput!]
  side: LinkSide!
}

input EditEquipmentPortTypeInput {
  id: ID!
  linkProperties: [PropertyTypeInput!]
  name: String!
  properties: [PropertyTypeInput!]
}

input EditEquipmentTypeInput {
  category: String
  id: ID!
  name: String!
  ports: [EquipmentPortInput!]
  positions: [EquipmentPositionInput!]
  properties: [PropertyTypeInput!]
}

input EditEventSeverityInput {
  id: ID!
  name: String!
}

input EditFlowInstanceInput {
  bssCode: String
  endDate: Time
  id: ID!
  serviceInstanceCode: String
  startParams: [VariableValueInput]
  status: FlowInstanceStatus
}

input EditFormulaInput {
  id: ID!
  kpiFk: ID!
  networkTypeFk: ID!
  status: Boolean!
  techFk: ID!
  textFormula: String!
}

input EditIsListableInput {
  id: ID!
  isListable: Boolean!
}

input EditKpiCategoryInput {
  id: ID!
  name: String!
}

input EditKpiInput {
  description: String!
  domainFk: ID!
  id: ID!
  kpiCategoryFK: ID!
  name: String!
  status: Boolean!
}

input EditKqiCategoryInput {
  id: ID!
  name: String!
}

input EditKqiComparatorInput {
  comparatorFk: ID!
  comparatorType: String!
  id: ID!
  kqiTargetFk: ID!
  number: Float!
}

input EditKqiInput {
  description: String!
  endDateTime: Time!
  formula: String!
  id: ID!
  kqiCategory: ID!
  kqiPerspective: ID!
  kqiSource: ID!
  kqiTemporalFrequency: ID!
  name: String!
  startDateTime: Time!
}

input EditKqiPerspectiveInput {
  id: ID!
  name: String!
}

input EditKqiSourceInput {
  id: ID!
  name: String!
}

input EditKqiTargetInput {
  allowedVariation: Float!
  endTime: Time!
  id: ID!
  impact: String!
  initTime: Time!
  kqi: ID!
  name: String!
  period: Float!
  status: Boolean!
}

input EditKqiTemporalFrequencyInput {
  id: ID!
  name: String!
}

input EditLinkInput {
  id: ID!
  properties: [PropertyInput!]
  serviceIds: [ID!]
}

input EditLocationInput {
  externalID: String
  id: ID!
  latitude: Float!
  longitude: Float!
  name: String!
  properties: [PropertyInput!]
}

input EditLocationTypeInput {
  documentCategories: [DocumentCategoryInput!]
  id: ID!
  isSite: Boolean
  mapType: String
  mapZoomLevel: Int
  name: String!
  properties: [PropertyTypeInput!]
}

input EditNetworkTypeInput {
  id: ID!
  name: String!
}

input EditOrganizationInput {
  description: String!
  id: ID!
  name: String!
}

input EditParameterCatalogInput {
  disabled: Boolean
  id: ID
  index: Int!
  name: String!
}

input EditPermissionsPolicyInput {
  assuranceInput: AssurancePolicyInput
  automationInput: AutomationPolicyInput
  description: String
  groups: [ID!]
  id: ID!
  inventoryInput: InventoryPolicyInput
  isGlobal: Boolean
  isMulticontractor: Boolean
  name: String
  workforceInput: WorkforcePolicyInput
}

input EditProjectInput {
  creatorId: ID
  description: String
  id: ID!
  location: ID
  name: String!
  priority: ProjectPriority
  properties: [PropertyInput!]
  type: ID!
}

input EditProjectTypeInput {
  description: String
  id: ID!
  name: String!
  properties: [PropertyTypeInput!]
  workOrders: [WorkOrderDefinitionInput!]
}

input EditPropertyCategoryInput {
  id: ID
  index: Int!
  name: String!
  parameterCatalogId: ID!
}

input EditPropertyTypeInput {
  id: ID!
  isDeleted: Boolean!
}

input EditPropertyTypeValueInput {
  id: ID
  isDeleted: Boolean
  name: String!
}

input EditRecommendationsCategoryInput {
  id: ID!
  name: String!
}

input EditRecommendationsInput {
  alarmType: String!
  command: String
  externalID: String!
  id: ID!
  longDescription: String!
  priority: Int!
  recommendationsCategory: ID!
  recommendationsSources: ID!
  resource: String!
  runbook: String
  shortDescription: String!
  status: Boolean!
  used: Int
  userApprobed: ID
  vendor: ID!
}

input EditRecommendationsSourcesInput {
  id: ID!
  name: String!
}

input EditReportFilterInput {
  id: ID!
  name: String!
}

input EditResourceSpecificationInput {
  id: ID!
  name: String!
  quantity: Int
  resourcePropertyTypes: [AddResourcePropertyTypeInput]
  resourceType: ID
  vendor: ID
}

input EditResourceSpecificationItemsInput {
  id: ID!
  resourceSpecification: ID
  resourceSpecificationRelationship: ID
}

input EditResourceSpecificationRelationshipInput {
  id: ID!
  name: String!
  resourceSpecification: ID
}

input EditResourceTypeInput {
  id: ID!
  name: String!
  resourceTypeBaseType: ResourceTypeBaseTypeKind!
  resourceTypeClass: ResourceTypeClassKind!
}

input EditResourceTypeRelationshipInput {
  id: ID!
  locationType: ID
  resourceRelationshipMultiplicity: ResourceRelationshipMultiplicityKind!
  resourceRelationshipType: ResourceRelationshipTypeKind!
  resourceTypeA: ID!
  resourceTypeB: ID
}

input EditRuleInput {
  additionalInfo: String
  endDateTime: Time
  eventSeverity: ID!
  eventTypeName: String
  gracePeriod: Int
  id: ID!
  name: String!
  ruleType: ID!
  specificProblem: String
  startDateTime: Time
  status: Boolean!
  threshold: ID!
}

input EditRuleLimitInput {
  comparator: ID!
  id: ID!
  limitType: String!
  number: Int!
  rule: ID!
}

input EditRuleTypeInput {
  id: ID!
  name: String!
}

input EditTechInput {
  domainFk: ID!
  id: ID!
  name: String!
}

input EditThresholdInput {
  description: String!
  id: ID!
  name: String!
  status: Boolean!
}

input EditUserInput {
  distanceUnit: DistanceUnit
  firstName: String
  id: ID!
  lastName: String
  organizationFk: ID
  role: UserRole
  status: UserStatus
}

input EditUsersGroupInput {
  description: String
  id: ID!
  members: [ID!]
  name: String
  policies: [ID!]
  status: UsersGroupStatus
}

input EditVendorInput {
  id: ID!
  name: String!
}

input EditWorkOrderInput {
  assigneeId: ID
  checkList: [CheckListItemInput!]
  checkListCategories: [CheckListCategoryInput!]
  description: String
  dueDate: Time
  duration: Float
  flowInstanceId: ID
  id: ID!
  index: Int
  installDate: Time
  isNameEditable: Boolean
  locationId: ID
  name: String!
  organizationFk: ID
  ownerId: ID
  priority: WorkOrderPriority
  projectId: ID
  properties: [PropertyInput!]
  scheduledAt: Time
  status: WorkOrderStatus
}

input EditWorkOrderTypeInput {
  assigneeCanCompleteWorkOrder: Boolean
  checkListCategories: [CheckListCategoryDefinitionInput!]
  description: String
  duration: Float
  id: ID!
  name: String!
  properties: [PropertyTypeInput]
}

input EditWorkerTypeInput {
  description: String
  id: ID!
  name: String!
  propertyTypes: [PropertyTypeInput!]
}

type EndBlock {
  entryPoint: EntryPoint!
  params: [VariableExpression!]!
}

input EndBlockInput {
  cid: String!
  params: [VariableExpressionInput!]!
  uiRepresentation: BlockUIRepresentationInput
}

"""End To End Path Descovery."""
type EndToEndPath {
  """The links in the path"""
  links: [Link]

  """The start,end ports in the path"""
  ports: [EquipmentPort]
}

type EntryPoint implements Node {
  cid: String
  id: ID!
  parentBlock: Block!
  prevExitPoints: [ExitPoint!]!
}

input EntryPointInput {
  cid: String
  role: EntryPointRole
}

enum EntryPointRole {
  DEFAULT
}

type Equipment implements NamedNode & Node {
  descendentsIncludingSelf: [Equipment]!
  equipmentType: EquipmentType!
  externalId: String
  files: [File]!
  firstLocation: Location!
  futureState: FutureState
  hyperlinks: [Hyperlink!]!
  id: ID!
  images: [File]!
  locationHierarchy: [Location!]!
  name: String!
  parentLocation: Location
  parentPosition: EquipmentPosition
  ports(availableOnly: Boolean = false): [EquipmentPort]!
  positionHierarchy: [EquipmentPosition!]!
  positions: [EquipmentPosition]!
  properties: [Property]!
  services: [Service]!
  workOrder: WorkOrder
}

"""A connection to a list of equipments."""
type EquipmentConnection {
  """A list of equipment edges."""
  edges: [EquipmentEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of equipment in all pages."""
  totalCount: Int!
}

"""An equipment edge in a connection."""
type EquipmentEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The equipment at the end of the edge."""
  node: Equipment
}

input EquipmentFilterInput {
  filterType: EquipmentFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  propertyValue: PropertyTypeInput
  stringSet: [String!]
  stringValue: String
}

"""what type of equipment we filter about"""
enum EquipmentFilterType {
  EQUIPMENT_TYPE
  EQUIP_INST_EXTERNAL_ID
  EQUIP_INST_NAME
  LOCATION_INST
  LOCATION_INST_EXTERNAL_ID
  PROPERTY
}

"""Ordering options for equipment connections."""
input EquipmentOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order equipment by."""
  field: EquipmentOrderField
}

"""Properties by which equipment connections can be ordered."""
enum EquipmentOrderField {
  """Order equipment by future state."""
  FUTURE_STATE

  """Order equipment by name."""
  NAME
}

type EquipmentPort implements Node {
  definition: EquipmentPortDefinition!
  id: ID!
  link: Link
  parentEquipment: Equipment!
  properties: [Property!]!
  serviceEndpoints: [ServiceEndpoint!]!
  services: [Service]!
}

"""A connection to a list of equipment ports."""
type EquipmentPortConnection {
  """A list of equipment port edges."""
  edges: [EquipmentPortEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of equipment ports in all pages."""
  totalCount: Int!
}

input EquipmentPortConnectionInput {
  id: ID
  name: String
}

type EquipmentPortDefinition implements Node {
  bandwidth: String
  connectedPorts: [EquipmentPortDefinition!]
  id: ID!
  index: Int
  name: String!
  portType: EquipmentPortType
  visibleLabel: String
}

"""A connection to a list of equipment port definitions."""
type EquipmentPortDefinitionConnection {
  """A list of equipment port definition edges."""
  edges: [EquipmentPortDefinitionEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of equipment port definitions in all pages."""
  totalCount: Int!
}

"""An equipment port definition edge in a connection."""
type EquipmentPortDefinitionEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The equipment port definition at the end of the edge."""
  node: EquipmentPortDefinition
}

"""An equipment port edge in a connection."""
type EquipmentPortEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The equipment port at the end of the edge."""
  node: EquipmentPort
}

input EquipmentPortInput {
  bandwidth: String
  connectedPorts: [EquipmentPortConnectionInput!]
  id: ID
  index: Int
  name: String!
  portTypeID: ID
  visibleLabel: String
}

type EquipmentPortType implements Node {
  id: ID!
  linkPropertyTypes: [PropertyType]!
  name: String!
  numberOfPortDefinitions: Int!
  propertyTypes: [PropertyType]!
}

"""A connection to a list of equipment port types."""
type EquipmentPortTypeConnection {
  """A list of equipment port type edges."""
  edges: [EquipmentPortTypeEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of equipment port types in all pages."""
  totalCount: Int!
}

"""An equipment port type edge in a connection."""
type EquipmentPortTypeEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The equipment port type at the end of the edge."""
  node: EquipmentPortType
}

type EquipmentPosition implements Node {
  attachedEquipment: Equipment
  definition: EquipmentPositionDefinition!
  id: ID!
  parentEquipment: Equipment!
}

type EquipmentPositionDefinition implements Node {
  id: ID!
  index: Int
  name: String!
  visibleLabel: String
}

input EquipmentPositionInput {
  id: ID
  index: Int
  name: String!
  visibleLabel: String
}

type EquipmentSearchResult {
  count: Int!
  equipment: [Equipment]!
}

type EquipmentType implements Node {
  category: String
  equipments: [Equipment]!
  id: ID!
  name: String!
  numberOfEquipment: Int!
  portDefinitions: [EquipmentPortDefinition]!
  positionDefinitions: [EquipmentPositionDefinition]!
  propertyTypes: [PropertyType]!
}

"""A connection to a list of equipment types."""
type EquipmentTypeConnection {
  """A list of equipment type edges."""
  edges: [EquipmentTypeEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of equipment types in all pages."""
  totalCount: Int!
}

"""An equipment type edge in a connection."""
type EquipmentTypeEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The equipment type at the end of the edge."""
  node: EquipmentType
}

type EventSeverity implements Node {
  id: ID!
  name: String!
  rule: [Rule!]
}

"""A connection to a list of eventSeverities."""
type EventSeverityConnection {
  """A list of eventSeverities edges."""
  edges: [EventSeverityEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total eventSeverities of projects in all pages."""
  totalCount: Int!
}

"""A eventSeverities edge in a connection."""
type EventSeverityEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The eventSeverities at the end of the edge."""
  node: EventSeverity
}

input EventSeverityFilterInput {
  filterType: EventSeverityFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum EventSeverityFilterType {
  NAME
}

"""Ordering options for eventSeverities connections."""
input EventSeverityOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order eventSeverities by."""
  field: EventSeverityOrderField
}

"""Properties by which eventSeverities connections can be ordered."""
enum EventSeverityOrderField {
  """Order eventSeverities by creation time."""
  CREATED_AT

  """Order eventSeverities by name."""
  NAME

  """Order eventSeverities by update time."""
  UPDATED_AT
}

type ExecuteFlowBlock {
  entryPoint: EntryPoint!
  exitPoint: ExitPoint!
  flow: Flow
  params: [VariableExpression!]!
}

input ExecuteFlowBlockInput {
  basicDefinitions: BaseBlockInput!
  cid: String!
  entryPoint: EntryPointInput
  exitPoint: ExitPointInput
  flow: ID!
  params: [VariableExpressionInput!]!
  uiRepresentation: BlockUIRepresentationInput
}

type ExitPoint implements Node {
  cid: String
  condition: VariableExpression
  id: ID!
  index: Int
  nextEntryPoints: [EntryPoint!]!
  parentBlock: Block!
}

input ExitPointInput {
  cid: String
  role: ExitPointRole
}

enum ExitPointRole {
  CHOICE
  DEFAULT
}

enum ExportStatus {
  FAILED
  IN_PROGRESS
  PENDING
  SUCCEEDED
}

type ExportTask implements Node {
  filters: [GeneralFilter!]!
  id: ID!
  progress: Float!
  status: ExportStatus!
  storeKey: String!
  type: ExportType!
}

enum ExportType {
  EQUIPMENT
  LINK
  LOCATION
  PORT
  SERVICE
  WORK_ORDER
}

type Field {
  name: String!
  type: String!
  value: String!
}

type File implements Node {
  annotation: String
  category: String
  documentCategory: DocumentCategory
  fileName: String!
  fileType: FileType
  id: ID!
  mimeType: String
  modified: Time
  sizeInBytes: Int
  storeKey: String
  uploaded: Time
  workorder: WorkOrder
}

input FileInput {
  annotation: String
  fileName: String!
  fileType: FileType
  id: ID
  mimeType: String
  modificationTime: Int
  sizeInBytes: Int
  storeKey: String!
  uploadTime: Int
}

enum FileType {
  FILE
  IMAGE
}

enum FilterEntity {
  EQUIPMENT
  LINK
  LOCATION
  PORT
  SERVICE
  WORK_ORDER
}

"""operators to filter search by"""
enum FilterOperator {
  CONTAINS
  DATE_GREATER_OR_EQUAL_THAN
  DATE_GREATER_THAN
  DATE_LESS_OR_EQUAL_THAN
  DATE_LESS_THAN
  IS
  IS_NIL
  IS_NIL_OR_DATE_GREATER_OR_EQUAL_THAN
  IS_NOT_ONE_OF
  IS_ONE_OF
}

input FloatFilter {
  between: FloatRange
  eq: Float
  ge: Float
  gt: Float
  in: [Float]
  le: Float
  lt: Float
}

input FloatRange {
  max: Float!
  min: Float!
}

type FloorPlan implements Node {
  id: ID!
  image: File!
  locationID: ID!
  name: String!
  referencePoint: FloorPlanReferencePoint!
  scale: FloorPlanScale!
}

type FloorPlanReferencePoint {
  latitude: Float!
  longitude: Float!
  x: Int!
  y: Int!
}

type FloorPlanScale {
  referencePoint1X: Int!
  referencePoint1Y: Int!
  referencePoint2X: Int!
  referencePoint2Y: Int!
  scaleInMeters: Float!
}

type Flow implements Node {
  author: User!
  blocks: [Block!]!
  cmType: FlowCMType
  connectors: [Connector!]!
  creationDate: Time!
  description: String
  draft: FlowDraft
  editor: User!
  endParamDefinitions: [VariableDefinition!]!
  failedInstances: Int!
  id: ID!
  name: String!
  newInstancesPolicy: FlowNewInstancesPolicy!
  runningInstances: Int!
  status: FlowStatus!
  updateTime: Time!
}

enum FlowCMType {
  GENERAL_CR
  INITIAL_CONFIG
  SYNC_PARAMETERS
}

"""A connection to a list of Flows."""
type FlowConnection {
  """A list of Flow edges."""
  edges: [FlowEdge!]

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of Flows in all pages."""
  totalCount: Int!
}

type FlowDraft implements Node {
  blocks: [Block!]!
  connectors: [Connector!]!
  description: String
  endParamDefinitions: [VariableDefinition!]!
  id: ID!
  name: String!
  sameAsFlow: Boolean!
}

"""A connection to a list of FlowDrafts."""
type FlowDraftConnection {
  """A list of FlowDraft edges."""
  edges: [FlowDraftEdge!]

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of FlowDrafts in all pages."""
  totalCount: Int!
}

"""A flow draft edge in a connection."""
type FlowDraftEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The FlowDraft type at the end of the edge."""
  node: FlowDraft
}

"""A flow edge in a connection."""
type FlowEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The Flow type at the end of the edge."""
  node: Flow
}

type FlowExecutionTemplate implements Node {
  blocks: [Block!]!
  connectors: [Connector!]!
  description: String
  id: ID!
  name: String!
}

input FlowFilterInput {
  cmType: FlowCMType
  filterType: FlowFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
  timeValue: Time
}

enum FlowFilterType {
  FLOW_CM_TYPE
  FLOW_NAME
}

type FlowInstance implements Node {
  activities(filter: AutomationActivityFilterInput): [AutomationActivity!]!
  blocks: [BlockInstance!]!
  bssCode: String
  endDate: Time
  id: ID!
  incompletion_reason: String
  serviceInstanceCode: String
  startDate: Time!
  startParams: [VariableValue!]
  status: FlowInstanceStatus!
  template: FlowExecutionTemplate!
}

"""A connection to a list of Flows."""
type FlowInstanceConnection {
  """A list of Flow edges."""
  edges: [FlowInstanceEdge!]

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of Flows in all pages."""
  totalCount: Int!
}

"""A flow edge in a connection."""
type FlowInstanceEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The Flow type at the end of the edge."""
  node: FlowInstance
}

input FlowInstanceFilterInput {
  filterType: FlowInstanceFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  propertyValue: PropertyTypeInput
  stringSet: [String!]
  stringValue: String
  timeValue: Time
}

"""what filters should we apply on flow instances"""
enum FlowInstanceFilterType {
  FLOW_INSTANCE_BSS_CODE
  FLOW_INSTANCE_SERVICE_INSTANCE_CODE
  FLOW_INSTANCE_STATUS
  FLOW_INSTANCE_TYPE
}

"""Ordering options for flow instance connections."""
input FlowInstanceOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order work orders by."""
  field: FlowInstanceOrderField
}

"""Properties by which flow instances connections can be ordered."""
enum FlowInstanceOrderField {
  """Order flow instances by end time."""
  END_AT

  """Order flow instances by start time."""
  START_AT

  """Order flow instances by update time."""
  UPDATED_AT
}

enum FlowInstanceStatus {
  CANCELED
  CANCELING
  CLOSED
  COMPLETED
  FAILED
  FAILING
  PAUSED
  PAUSING
  RESUMING
  RUNNING
}

enum FlowNewInstancesPolicy {
  DISABLED
  ENABLED
}

"""Ordering options for ResourceType connections."""
input FlowOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order ResourceType by."""
  field: FlowOrderField
}

enum FlowOrderField {
  """Order Flow by CMType."""
  CM_TYPE

  """Order Flow by creation time."""
  CREATED_AT

  """Order Flow by name."""
  NAME
}

enum FlowStatus {
  ARCHIVED
  DELETED
  DRAFT
  ON_HOLD
  PUBLISHED
}

type ForEachBlock {
  entryPoint: EntryPoint!
  exitPoint: ExitPoint!
  internalExitPoint: ExitPoint!
}

type Formula implements Node {
  counterformulaFk: [CounterFormula]
  id: ID!
  kpiFk: Kpi!
  networkTypeFk: NetworkType!
  status: Boolean!
  techFk: Tech!
  textFormula: String!
}

"""A connection to a list of formulas."""
type FormulaConnection {
  """A list of formulas edges."""
  edges: [FormulaEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total formulas of projects in all pages."""
  totalCount: Int!
}

"""A formulas edge in a connection."""
type FormulaEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The formulas at the end of the edge."""
  node: Formula
}

input FormulaFilterInput {
  boolValue: Boolean
  filterType: FormulaFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum FormulaFilterType {
  STATUS
  TEXTFORMULA
}

"""Ordering options for formulas connections."""
input FormulaOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order formulas by."""
  field: FormulaOrderField
}

"""Properties by which formulas connections can be ordered."""
enum FormulaOrderField {
  """Order formulas by creation time."""
  CREATED_AT

  """Order formulas by name."""
  NAME

  """Order formulas by update time."""
  UPDATED_AT
}

"""FutureState of an equipment."""
enum FutureState {
  INSTALL
  REMOVE
}

type GeneralFilter {
  boolValue: Boolean
  filterType: String!
  idSet: [ID!]
  key: String!
  operator: FilterOperator!
  propertyValue: PropertyType
  stringSet: [String!]
  stringValue: String
}

input GeneralFilterInput {
  boolValue: Boolean
  filterType: String!
  idSet: [ID!]
  key: String!
  operator: FilterOperator!
  propertyValue: PropertyTypeInput
  stringSet: [String!]
  stringValue: String
}

input GenerateMutationParams {
  add: Boolean
  delete: Boolean
  update: Boolean
}

input GenerateQueryParams {
  aggregate: Boolean
  get: Boolean
  password: Boolean
  query: Boolean
}

enum GoToType {
  DESTINATION
  ORIGIN
}

type GotoBlock {
  entryPoint: EntryPoint!
  target: Block
}

input GotoBlockInput {
  cid: String!
  targetBlockCid: String
  type: GoToType!
  uiRepresentation: BlockUIRepresentationInput
}

enum HTTPMethod {
  DELETE
  GET
  PATCH
  POST
  PUT
}

type Hyperlink implements Node {
  category: String
  createTime: Time!
  displayName: String
  documentCategory: DocumentCategory
  id: ID!
  url: String!
}

enum ImageEntity {
  CHECKLIST_ITEM
  EQUIPMENT
  LOCATION
  SITE_SURVEY
  USER
  WORK_ORDER
}

input ImportFlowDraftInput {
  actionBlocks: [ActionBlockInput!]
  choiceBlocks: [ChoiceBlockInput!]
  connectors: [ConnectorInput!]
  description: String
  endBlocks: [EndBlockInput!]
  endParamDefinitions: [VariableDefinitionInput!]!
  executeFlowBlocks: [ExecuteFlowBlockInput!]
  gotoBlocks: [GotoBlockInput!]
  id: ID!
  invokeRestAPIBlocks: [InvokeRestAPIBlockInput!]
  kafkaBlocks: [KafkaBlockInput!]
  name: String!
  startBlock: StartBlockInput
  timerBlocks: [TimerBlockInput!]
  triggerBlocks: [TriggerBlockInput!]
  waitForSignalBlocks: [WaitForSignalBlockInput!]
}

scalar Int64

input Int64Filter {
  between: Int64Range
  eq: Int64
  ge: Int64
  gt: Int64
  in: [Int64]
  le: Int64
  lt: Int64
}

input Int64Range {
  max: Int64!
  min: Int64!
}

input IntFilter {
  between: IntRange
  eq: Int
  ge: Int
  gt: Int
  in: [Int]
  le: Int
  lt: Int
}

input IntRange {
  max: Int!
  min: Int!
}

input IntersectsFilter {
  multiPolygon: MultiPolygonRef
  polygon: PolygonRef
}

type InventoryPolicy {
  documentCategory: DocumentCategoryCUD!
  equipment: CUD!
  equipmentType: CUD!
  location: LocationCUD!
  locationType: CUD!
  portType: CUD!
  propertyCategory: PropertyCategoryCUD!
  read: BasicPermissionRule!
  serviceType: CUD!
}

input InventoryPolicyInput {
  documentCategory: DocumentCategoryCUDInput
  equipment: BasicCUDInput
  equipmentType: BasicCUDInput
  location: LocationCUDInput
  locationType: BasicCUDInput
  portType: BasicCUDInput
  propertyCategory: PropertyCategoryCUDInput
  read: BasicPermissionRuleInput
  serviceType: BasicCUDInput
}

type InvokeRestAPIBlock {
  authType: AuthType
  body: String!
  clientId: String
  clientSecret: String
  connectionTimeOut: Int!
  entryPoint: EntryPoint!
  exitPoint: ExitPoint!
  headers: [VariableValue!]!
  method: UrlMethod!
  oidcUrl: String
  password: String
  url: String!
  user: String
}

input InvokeRestAPIBlockInput {
  authType: AuthType
  basicDefinitions: BaseBlockInput!
  body: String!
  cid: String!
  clientId: String
  clientSecret: String
  connectionTimeOut: Int!
  entryPoint: EntryPointInput
  exitPoint: ExitPointInput
  headers: [VariableValueInput]!
  method: UrlMethod!
  oidcUrl: String
  params: [VariableExpressionInput!]
  password: String
  uiRepresentation: BlockUIRepresentationInput
  url: String!
  user: String
}

type KafkaBlock {
  brokers: [String!]
  entryPoint: EntryPoint!
  exitPoint: ExitPoint!
  message: String!
  topic: String!
  type: KafkaMessageType!
}

input KafkaBlockInput {
  basicDefinitions: BaseBlockInput!
  brokers: [String!]
  cid: String!
  entryPoint: EntryPointInput
  exitPoint: ExitPointInput
  message: String!
  topic: String!
  type: KafkaMessageType!
  uiRepresentation: BlockUIRepresentationInput
}

enum KafkaMessageType {
  EXPRESSION
  INPUT
  STATE
}

type Kpi implements Node {
  description: String!
  domainFk: Domain!
  formulaFk: [Formula]
  id: ID!
  kpiCategoryFK: KpiCategory!
  name: String!
  status: Boolean!
  threshold: Threshold!
}

type KpiCategory implements Node {
  id: ID!
  name: String!
}

"""A connection to a list of kpiCategoriess."""
type KpiCategoryConnection {
  """A list of kpiCategoriess edges."""
  edges: [KpiCategoryEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total kpiCategoriess of projects in all pages."""
  totalCount: Int!
}

"""A kpiCategoriess edge in a connection."""
type KpiCategoryEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The kpiCategoriess at the end of the edge."""
  node: KpiCategory
}

input KpiCategoryFilterInput {
  filterType: KpiCategoryFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum KpiCategoryFilterType {
  NAME
}

"""Ordering options for kpiCategoriess connections."""
input KpiCategoryOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order kpiCategoriess by."""
  field: KpiCategoryOrderField
}

"""Properties by which kpiCategoriess connections can be ordered."""
enum KpiCategoryOrderField {
  """Order kpiCategoriess by creation time."""
  CREATED_AT

  """Order kpiCategoriess by name."""
  NAME

  """Order kpiCategoriess by update time."""
  UPDATED_AT
}

"""A connection to a list of kpi's."""
type KpiConnection {
  """A list of kpi's edges."""
  edges: [KpiEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total kpi's of projects in all pages."""
  totalCount: Int!
}

"""A kpi's edge in a connection."""
type KpiEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The kpi's at the end of the edge."""
  node: Kpi
}

input KpiFilterInput {
  filterType: KpiFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum KpiFilterType {
  NAME
}

"""Ordering options for kpi's connections."""
input KpiOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order kpi's by."""
  field: KpiOrderField
}

"""Properties by which kpi's connections can be ordered."""
enum KpiOrderField {
  """Order kpi's by creation time."""
  CREATED_AT

  """Order kpi's by name."""
  NAME

  """Order kpi's by update time."""
  UPDATED_AT
}

type Kqi implements Node {
  description: String!
  endDateTime: Time!
  formula: String!
  id: ID!
  kqiCategory: KqiCategory!
  kqiPerspective: KqiPerspective!
  kqiSource: KqiSource!
  kqiTarget: [KqiTarget!]
  kqiTemporalFrequency: KqiTemporalFrequency!
  name: String!
  startDateTime: Time!
}

type KqiCategory implements Node {
  id: ID!
  kqi: [Kqi!]
  name: String!
}

"""A connection to a list of kqi category."""
type KqiCategoryConnection {
  """A list of kqi category edges."""
  edges: [KqiCategoryEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total kqi category of projects in all pages."""
  totalCount: Int!
}

"""A kqi category edge in a connection."""
type KqiCategoryEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The kqi category at the end of the edge."""
  node: KqiCategory
}

input KqiCategoryFilterInput {
  filterType: KqiCategoryFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum KqiCategoryFilterType {
  NAME
}

"""Ordering options for kqi category connections."""
input KqiCategoryOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order kqi category by."""
  field: KqiCategoryOrderField
}

"""Properties by which kqi category connections can be ordered."""
enum KqiCategoryOrderField {
  """Order kqi category by creation time."""
  CREATED_AT

  """Order kqi category by name."""
  NAME

  """Order kqi category by update time."""
  UPDATED_AT
}

type KqiComparator implements Node {
  comparatorFk: Comparator!
  comparatorType: String!
  id: ID!
  kqiTargetFk: KqiTarget!
  number: Float!
}

"""A connection to a list of Kqi."""
type KqiConnection {
  """A list of Kqi edges."""
  edges: [KqiEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total Kqi of projects in all pages."""
  totalCount: Int!
}

"""A Kqi edge in a connection."""
type KqiEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The Kqi at the end of the edge."""
  node: Kqi
}

input KqiFilterInput {
  filterType: KqiFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum KqiFilterType {
  NAME
}

"""Ordering options for Kqi connections."""
input KqiOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order Kqi by."""
  field: KqiOrderField
}

"""Properties by which Kqi connections can be ordered."""
enum KqiOrderField {
  """Order Kqi by creation time."""
  CREATED_AT

  """Order Kqi by name."""
  NAME

  """Order Kqi by update time."""
  UPDATED_AT
}

type KqiPerspective implements Node {
  id: ID!
  kqi: [Kqi!]
  name: String!
}

"""A connection to a list of kqi perspective."""
type KqiPerspectiveConnection {
  """A list of kqi perspective edges."""
  edges: [KqiPerspectiveEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total kqi perspective of projects in all pages."""
  totalCount: Int!
}

"""A kqi perspective edge in a connection."""
type KqiPerspectiveEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The kqi perspective at the end of the edge."""
  node: KqiPerspective
}

input KqiPerspectiveFilterInput {
  filterType: KqiPerspectiveFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum KqiPerspectiveFilterType {
  NAME
}

"""Ordering options for kqi perspective connections."""
input KqiPerspectiveOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order kqi perspective by."""
  field: KqiPerspectiveOrderField
}

"""Properties by which kqi perspective connections can be ordered."""
enum KqiPerspectiveOrderField {
  """Order kqi perspective by creation time."""
  CREATED_AT

  """Order kqi perspective by name."""
  NAME

  """Order kqi perspective by update time."""
  UPDATED_AT
}

type KqiSource implements Node {
  id: ID!
  kqi: [Kqi!]
  name: String!
}

"""A connection to a list of kqi source."""
type KqiSourceConnection {
  """A list of kqi source edges."""
  edges: [KqiSourceEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total kqi source of projects in all pages."""
  totalCount: Int!
}

"""A kqi source edge in a connection."""
type KqiSourceEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The kqi source at the end of the edge."""
  node: KqiSource
}

input KqiSourceFilterInput {
  filterType: KqiSourceFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum KqiSourceFilterType {
  NAME
}

"""Ordering options for kqi source connections."""
input KqiSourceOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order kqi source by."""
  field: KqiSourceOrderField
}

"""Properties by which kqi source connections can be ordered."""
enum KqiSourceOrderField {
  """Order kqi source by creation time."""
  CREATED_AT

  """Order kqi source by name."""
  NAME

  """Order kqi source by update time."""
  UPDATED_AT
}

type KqiTarget implements Node {
  allowedVariation: Float!
  endTime: Time!
  id: ID!
  impact: String!
  initTime: Time!
  kqi: Kqi!
  kqiComparator: [KqiComparator]!
  name: String!
  period: Float!
  status: Boolean!
}

"""A connection to a list of kqi target."""
type KqiTargetConnection {
  """A list of kqi target edges."""
  edges: [KqiTargetEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total kqi target of projects in all pages."""
  totalCount: Int!
}

"""A kqi target edge in a connection."""
type KqiTargetEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The kqi target at the end of the edge."""
  node: KqiTarget
}

input KqiTargetFilterInput {
  filterType: KqiTargetFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum KqiTargetFilterType {
  NAME
}

"""Ordering options for kqi target connections."""
input KqiTargetOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order kqi target by."""
  field: KqiTargetOrderField
}

"""Properties by which kqi target connections can be ordered."""
enum KqiTargetOrderField {
  """Order kqi target by creation time."""
  CREATED_AT

  """Order kqi target by name."""
  NAME

  """Order kqi target by update time."""
  UPDATED_AT
}

type KqiTemporalFrequency implements Node {
  id: ID!
  kqi: [Kqi!]
  name: String!
}

"""A connection to a list of kqi temporal frequency."""
type KqiTemporalFrequencyConnection {
  """A list of kqi temporal frequency edges."""
  edges: [KqiTemporalFrequencyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total kqi temporal frequency of projects in all pages."""
  totalCount: Int!
}

"""A kqi temporal frequency edge in a connection."""
type KqiTemporalFrequencyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The kqi temporal frequency at the end of the edge."""
  node: KqiTemporalFrequency
}

input KqiTemporalFrequencyFilterInput {
  filterType: KqiTemporalFrequencyFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum KqiTemporalFrequencyFilterType {
  NAME
}

"""Ordering options for kqi temporal frequency connections."""
input KqiTemporalFrequencyOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order kqi temporal frequency by."""
  field: KqiTemporalFrequencyOrderField
}

"""Properties by which kqi temporal frequency connections can be ordered."""
enum KqiTemporalFrequencyOrderField {
  """Order kqi temporal frequency by creation time."""
  CREATED_AT

  """Order kqi temporal frequency by name."""
  NAME

  """Order kqi temporal frequency by update time."""
  UPDATED_AT
}

type LatestPythonPackageResult {
  lastBreakingPythonPackage: PythonPackage
  lastPythonPackage: PythonPackage
}

enum LifecycleStatus {
  INSTALLING
  OPERATING
  PLANNING
  RETIRING
}

type Link implements Node {
  futureState: FutureState
  id: ID!
  ports: [EquipmentPort]!
  properties: [Property]!
  services: [Service]!
  workOrder: WorkOrder
}

"""A connection to a list of links."""
type LinkConnection {
  """A list of link edges."""
  edges: [LinkEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of links in all pages."""
  totalCount: Int!
}

"""A link edge in a connection."""
type LinkEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The link at the end of the edge."""
  node: Link
}

input LinkFilterInput {
  filterType: LinkFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  propertyValue: PropertyTypeInput
  stringSet: [String!]
  stringValue: String
}

"""what filters should we apply on links"""
enum LinkFilterType {
  EQUIPMENT_INST
  EQUIPMENT_TYPE
  LINK_FUTURE_STATUS
  LOCATION_INST
  LOCATION_INST_EXTERNAL_ID
  PROPERTY
  SERVICE_INST
}

type LinkSearchResult {
  count: Int!
  links: [Link]!
}

input LinkSide {
  equipment: ID!
  port: ID!
}

type Location implements NamedNode & Node {
  cellData: [SurveyCellScan]!
  children: [Location]!
  distanceKm(latitude: Float!, longitude: Float!): Float!
  equipments: [Equipment]!
  externalId: String
  files: [File]!
  floorPlans: [FloorPlan]!
  hyperlinks: [Hyperlink!]!
  id: ID!
  images: [File]!
  latitude: Float!
  locationHierarchy: [Location!]!
  locationType: LocationType!
  longitude: Float!
  name: String!
  numChildren: Int!
  parentCoords: Coordinates
  parentLocation: Location
  properties: [Property]!
  siteSurveyNeeded: Boolean!
  surveys: [Survey]!
  topology(depth: Int! = 3): NetworkTopology!
  wifiData: [SurveyWiFiScan]!
}

type LocationCUD {
  create: LocationPermissionRule!
  delete: LocationPermissionRule!
  update: LocationPermissionRule!
}

input LocationCUDInput {
  create: BasicPermissionRuleInput
  delete: BasicPermissionRuleInput
  update: LocationPermissionRuleInput
}

"""A connection to a list of locations."""
type LocationConnection {
  """A list of location edges."""
  edges: [LocationEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of locations in all pages."""
  totalCount: Int!
}

"""A location edge in a connection."""
type LocationEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The location at the end of the edge."""
  node: Location
}

input LocationFilterInput {
  boolValue: Boolean
  filterType: LocationFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  propertyValue: PropertyTypeInput
  stringSet: [String!]
  stringValue: String
}

"""what filters should we apply on locations"""
enum LocationFilterType {
  LOCATION_INST
  LOCATION_INST_EXTERNAL_ID
  LOCATION_INST_HAS_EQUIPMENT
  LOCATION_INST_NAME
  LOCATION_TYPE
  PROPERTY
}

"""Ordering options for location connections."""
input LocationOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order locations by."""
  field: LocationOrderField
}

"""Properties by which location connections can be ordered."""
enum LocationOrderField {
  """Order locations by name."""
  NAME
}

type LocationPermissionRule {
  isAllowed: PermissionValue!
  locationTypeIds: [ID!]
}

input LocationPermissionRuleInput {
  isAllowed: PermissionValue!
  locationTypeIds: [ID!]
}

type LocationSearchResult {
  count: Int!
  locations: [Location]!
}

type LocationType implements Node {
  documentCategories: [DocumentCategory]!
  id: ID!
  index: Int
  isSite: Boolean!
  locations(enforceHasLatLong: Boolean = false): LocationConnection
  mapType: String
  mapZoomLevel: Int
  name: String!
  numberOfLocations: Int!
  propertyTypes: [PropertyType]!
  surveyTemplateCategories: [SurveyTemplateCategory]
}

"""A connection to a list of location types."""
type LocationTypeConnection {
  """A list of location type edges."""
  edges: [LocationTypeEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of location types in all pages."""
  totalCount: Int!
}

"""A location type edge in a connection."""
type LocationTypeEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The location type at the end of the edge."""
  node: LocationType
}

input LocationTypeIndex {
  index: Int!
  locationTypeID: ID!
}

enum Mode {
  BATCH
  SINGLE
}

type MultiPolygon {
  polygons: [Polygon!]!
}

input MultiPolygonRef {
  polygons: [PolygonRef!]!
}

type Mutation {
  addActionBlock(flowDraftId: ID!, input: ActionBlockInput!): Block! @join__field(graph: SYMPHONY)
  addAlarmFilter(input: AddAlarmFilterInput!): AlarmFilter! @join__field(graph: SYMPHONY)
  addAlarmStatus(input: AddAlarmStatusInput!): AlarmStatus! @join__field(graph: SYMPHONY)
  addAppointment(input: AddAppointmentInput!): Appointment! @join__field(graph: SYMPHONY)
  addBlockInstance(flowInstanceId: ID!, input: AddBlockInstanceInput!): BlockInstance! @join__field(graph: SYMPHONY)
  addBulkServiceLinksAndPorts(input: AddBulkServiceLinksAndPortsInput): Service! @join__field(graph: SYMPHONY)
  addCMVersion(input: [AddCMVersionInput!]!): AddCMVersionPayload @join__field(graph: DGRAPHSERVICE)
  addCellScans(
    """cell scan data"""
    data: [SurveyCellScanData]!

    """location of where cell scan was collected"""
    locationID: ID!
  ): [SurveyCellScan] @join__field(graph: SYMPHONY)
  addChangeItem(input: [AddChangeItemInput!]!): AddChangeItemPayload @join__field(graph: DGRAPHSERVICE)
  addChangeRequest(input: [AddChangeRequestInput!]!): AddChangeRequestPayload @join__field(graph: DGRAPHSERVICE)
  addChangeRequestActivity(input: [AddChangeRequestActivityInput!]!): AddChangeRequestActivityPayload @join__field(graph: DGRAPHSERVICE)
  addChoiceBlock(flowDraftId: ID!, input: ChoiceBlockInput!): Block! @join__field(graph: SYMPHONY)
  addComment(input: CommentInput!): Comment! @join__field(graph: SYMPHONY)
  addComparator(input: AddComparatorInput!): Comparator! @join__field(graph: SYMPHONY)
  addComposed_of(input: [AddComposed_ofInput!]!): AddComposed_ofPayload @join__field(graph: DGRAPHSERVICE)
  addConfigParamTag(input: [AddConfigParamTagInput!]!): AddConfigParamTagPayload @join__field(graph: DGRAPHSERVICE)
  addConfigurationParameterType(input: [AddConfigurationParameterTypeInput!]!): AddConfigurationParameterTypePayload @join__field(graph: DGRAPHSERVICE)
  addConnector(flowDraftId: ID!, input: ConnectorInput!): Connector! @join__field(graph: SYMPHONY)
  addCounter(input: AddCounterInput!): Counter! @join__field(graph: SYMPHONY)
  addCounterFamily(input: AddCounterFamilyInput!): CounterFamily! @join__field(graph: SYMPHONY)
  addCounterFormula(input: AddCounterFormulaInput!): CounterFormula! @join__field(graph: SYMPHONY)
  addCounterFormulaList(input: AddCounterFormulaListInput!): [CounterFormula!]! @join__field(graph: SYMPHONY)
  addCustomer(input: AddCustomerInput!): Customer! @join__field(graph: SYMPHONY)
  addDomain(input: AddDomainInput!): Domain! @join__field(graph: SYMPHONY)
  addEndBlock(flowDraftId: ID!, input: EndBlockInput!): Block! @join__field(graph: SYMPHONY)
  addEquipment(input: AddEquipmentInput!): Equipment! @join__field(graph: SYMPHONY)
  addEquipmentPortType(input: AddEquipmentPortTypeInput!): EquipmentPortType! @join__field(graph: SYMPHONY)
  addEquipmentType(input: AddEquipmentTypeInput!): EquipmentType! @join__field(graph: SYMPHONY)
  addEventSeverity(input: AddEventSeverityInput!): EventSeverity! @join__field(graph: SYMPHONY)
  addExecuteFlowBlock(flowDraftId: ID!, input: ExecuteFlowBlockInput!): Block! @join__field(graph: SYMPHONY)
  addFiles(input: AddFilesInput!): File! @join__field(graph: SYMPHONY)
  addFloorPlan(input: AddFloorPlanInput!): FloorPlan! @join__field(graph: SYMPHONY)
  addFlowDraft(input: AddFlowDraftInput!): FlowDraft! @join__field(graph: SYMPHONY)
  addFormula(input: AddFormulaInput!): Formula! @join__field(graph: SYMPHONY)
  addGotoBlock(flowDraftId: ID!, input: GotoBlockInput!): Block! @join__field(graph: SYMPHONY)
  addHyperlink(input: AddHyperlinkInput!): Hyperlink! @join__field(graph: SYMPHONY)
  addImage(input: AddImageInput!): File! @join__field(graph: SYMPHONY)
  addInvokeRestAPIBlock(flowDraftId: ID!, input: InvokeRestAPIBlockInput!): Block! @join__field(graph: SYMPHONY)
  addKafkaBlock(flowDraftId: ID!, input: KafkaBlockInput!): Block! @join__field(graph: SYMPHONY)
  addKpi(input: AddKpiInput!): Kpi! @join__field(graph: SYMPHONY)
  addKpiCategory(input: AddKpiCategoryInput!): KpiCategory! @join__field(graph: SYMPHONY)
  addKqi(input: AddKqiInput!): Kqi! @join__field(graph: SYMPHONY)
  addKqiCategory(input: AddKqiCategoryInput!): KqiCategory! @join__field(graph: SYMPHONY)
  addKqiComparator(input: AddKqiComparatorInput!): KqiComparator! @join__field(graph: SYMPHONY)
  addKqiPerspective(input: AddKqiPerspectiveInput!): KqiPerspective! @join__field(graph: SYMPHONY)
  addKqiSource(input: AddKqiSourceInput!): KqiSource! @join__field(graph: SYMPHONY)
  addKqiTarget(input: AddKqiTargetInput!): KqiTarget! @join__field(graph: SYMPHONY)
  addKqiTemporalFrequency(input: AddKqiTemporalFrequencyInput!): KqiTemporalFrequency! @join__field(graph: SYMPHONY)
  addLink(input: AddLinkInput!): Link! @join__field(graph: SYMPHONY)
  addLocation(input: AddLocationInput!): Location! @join__field(graph: SYMPHONY)
  addLocationType(input: AddLocationTypeInput!): LocationType! @join__field(graph: SYMPHONY)
  addNetworkType(input: AddNetworkTypeInput!): NetworkType! @join__field(graph: SYMPHONY)
  addOrganization(input: AddOrganizationInput!): Organization! @join__field(graph: SYMPHONY)
  addParameter(input: [AddParameterInput!]!): AddParameterPayload @join__field(graph: DGRAPHSERVICE)
  addPermissionsPolicy(input: AddPermissionsPolicyInput!): PermissionsPolicy! @join__field(graph: SYMPHONY)
  addPropertyTypeValue(input: AddPropertyTypeValueInput!): PropertyTypeValue! @join__field(graph: SYMPHONY)
  addRecommendations(input: AddRecommendationsInput!): Recommendations! @join__field(graph: SYMPHONY)
  addRecommendationsCategory(input: AddRecommendationsCategoryInput!): RecommendationsCategory! @join__field(graph: SYMPHONY)
  addRecommendationsList(input: AddRecommendationsListInput!): [Recommendations!]! @join__field(graph: SYMPHONY)
  addRecommendationsSources(input: AddRecommendationsSourcesInput!): RecommendationsSources! @join__field(graph: SYMPHONY)
  addReportFilter(input: ReportFilterInput!): ReportFilter! @join__field(graph: SYMPHONY)
  addResource(input: [AddResourceInput!]!, upsert: Boolean): AddResourcePayload @join__field(graph: DGRAPHSERVICE)
  addResourceProperty(input: [AddResourcePropertyInput!]!): AddResourcePropertyPayload @join__field(graph: DGRAPHSERVICE)
  addResourceSpecification(input: AddResourceSpecificationInput!): ResourceSpecification! @join__field(graph: SYMPHONY)
  addResourceSpecificationItems(input: AddResourceSpecificationItemsInput!): ResourceSpecificationItems! @join__field(graph: SYMPHONY)
  addResourceSpecificationRelationship(input: AddResourceSpecificationRelationshipInput!): ResourceSpecificationRelationship! @join__field(graph: SYMPHONY)
  addResourceSpecificationRelationshipList(input: [AddResourceSpecificationRelationshipInput!]!): [ResourceSpecificationRelationship!]! @join__field(graph: SYMPHONY)
  addResourceType(input: AddResourceTypeInput!): ResourceType! @join__field(graph: SYMPHONY)
  addResourceTypeRelationship(input: AddResourceTypeRelationshipInput!): ResourceTypeRelationship! @join__field(graph: SYMPHONY)
  addRule(input: AddRuleInput!): Rule! @join__field(graph: SYMPHONY)
  addRuleLimit(input: AddRuleLimitInput!): RuleLimit! @join__field(graph: SYMPHONY)
  addRuleType(input: AddRuleTypeInput!): RuleType! @join__field(graph: SYMPHONY)
  addSchedulerConfig(input: [AddSchedulerConfigInput!]!): AddSchedulerConfigPayload @join__field(graph: DGRAPHSERVICE)
  addService(
    """data to create service"""
    data: ServiceCreateData!
  ): Service! @join__field(graph: SYMPHONY)
  addServiceEndpoint(input: AddServiceEndpointInput!): Service! @join__field(graph: SYMPHONY)
  addServiceLink(id: ID!, linkId: ID!): Service! @join__field(graph: SYMPHONY)
  addServicePort(id: ID!, portId: ID!): Service! @join__field(graph: SYMPHONY)
  addServiceType(
    """
    AddServiceEndpointInput
    data to edit service type
    """
    data: ServiceTypeCreateData!
  ): ServiceType! @join__field(graph: SYMPHONY)
  addStartBlock(flowDraftId: ID!, input: StartBlockInput!): Block! @join__field(graph: SYMPHONY)
  addTech(input: AddTechInput!): Tech! @join__field(graph: SYMPHONY)
  addThreshold(input: AddThresholdInput!): Threshold! @join__field(graph: SYMPHONY)
  addTimerBlock(flowDraftId: ID!, input: TimerBlockInput!): Block! @join__field(graph: SYMPHONY)
  addTriggerBlock(flowDraftId: ID!, input: TriggerBlockInput!): Block! @join__field(graph: SYMPHONY)
  addUsersGroup(input: AddUsersGroupInput!): UsersGroup! @join__field(graph: SYMPHONY)
  addVendor(input: AddVendorInput!): Vendor! @join__field(graph: SYMPHONY)
  addWaitForSignalBlock(flowDraftId: ID!, input: WaitForSignalBlockInput!): Block! @join__field(graph: SYMPHONY)
  addWiFiScans(
    """wifi scan data"""
    data: [SurveyWiFiScanData]!

    """location of where wifi scan was collected"""
    locationID: ID!
  ): [SurveyWiFiScan] @join__field(graph: SYMPHONY)
  addWorkOrder(input: AddWorkOrderInput!): WorkOrder! @join__field(graph: SYMPHONY)
  addWorkOrderType(input: AddWorkOrderTypeInput!): WorkOrderType! @join__field(graph: SYMPHONY)
  addWorkerType(input: AddWorkerTypeInput!): WorkerType! @join__field(graph: SYMPHONY)
  archiveFlow(input: ArchiveFlowInput!): Flow! @join__field(graph: SYMPHONY)
  createProject(input: AddProjectInput!): Project! @join__field(graph: SYMPHONY)
  createProjectType(input: AddProjectTypeInput!): ProjectType! @join__field(graph: SYMPHONY)
  createSurvey(data: SurveyCreateData!): ID! @join__field(graph: SYMPHONY)
  deleteBlock(id: ID!): Boolean! @join__field(graph: SYMPHONY)
  deleteCMVersion(filter: CMVersionFilter!): DeleteCMVersionPayload @join__field(graph: DGRAPHSERVICE)
  deleteChangeItem(filter: ChangeItemFilter!): DeleteChangeItemPayload @join__field(graph: DGRAPHSERVICE)
  deleteChangeRequest(filter: ChangeRequestFilter!): DeleteChangeRequestPayload @join__field(graph: DGRAPHSERVICE)
  deleteChangeRequestActivity(filter: ChangeRequestActivityFilter!): DeleteChangeRequestActivityPayload @join__field(graph: DGRAPHSERVICE)
  deleteComposed_of(filter: Composed_ofFilter!): DeleteComposed_ofPayload @join__field(graph: DGRAPHSERVICE)
  deleteConfigParamTag(filter: ConfigParamTagFilter!): DeleteConfigParamTagPayload @join__field(graph: DGRAPHSERVICE)
  deleteConfigurationParameterType(filter: ConfigurationParameterTypeFilter!): DeleteConfigurationParameterTypePayload @join__field(graph: DGRAPHSERVICE)
  deleteConnector(flowDraftId: ID!, input: ConnectorInput!): Boolean! @join__field(graph: SYMPHONY)
  deleteFloorPlan(id: ID!): Boolean! @join__field(graph: SYMPHONY)
  deleteFlowDraft(id: ID!): Boolean! @join__field(graph: SYMPHONY)
  deleteHyperlink(id: ID!): Hyperlink! @join__field(graph: SYMPHONY)
  deleteImage(
    """id of the entity whre image is at"""
    entityId: ID!

    """type of the entity whre image is at"""
    entityType: ImageEntity!

    """id of the image file"""
    id: ID!
  ): File! @join__field(graph: SYMPHONY)
  deleteParameter(filter: ParameterFilter!): DeleteParameterPayload @join__field(graph: DGRAPHSERVICE)
  deletePermissionsPolicy(id: ID!): Boolean! @join__field(graph: SYMPHONY)
  deleteProject(id: ID!): Boolean! @join__field(graph: SYMPHONY)
  deleteProjectType(id: ID!): Boolean! @join__field(graph: SYMPHONY)
  deleteReportFilter(id: ID!): Boolean! @join__field(graph: SYMPHONY)
  deleteResource(filter: ResourceFilter!): DeleteResourcePayload @join__field(graph: DGRAPHSERVICE)
  deleteResourceProperty(filter: ResourcePropertyFilter!): DeleteResourcePropertyPayload @join__field(graph: DGRAPHSERVICE)
  deleteSchedulerConfig(filter: SchedulerConfigFilter!): DeleteSchedulerConfigPayload @join__field(graph: DGRAPHSERVICE)
  deleteUsersGroup(id: ID!): Boolean! @join__field(graph: SYMPHONY)
  duplicateFlow(input: DuplicateFlowInput!): Flow! @join__field(graph: SYMPHONY)
  editAlarmFilter(input: EditAlarmFilterInput!): AlarmFilter! @join__field(graph: SYMPHONY)
  editAlarmStatus(input: EditAlarmStatusInput!): AlarmStatus! @join__field(graph: SYMPHONY)
  editAppointment(input: EditAppointmentInput!): Appointment! @join__field(graph: SYMPHONY)
  editBlock(input: EditBlockInput!): Block! @join__field(graph: SYMPHONY)
  editBlockInstance(input: EditBlockInstanceInput!): BlockInstance! @join__field(graph: SYMPHONY)
  editComparator(input: EditComparatorInput!): Comparator! @join__field(graph: SYMPHONY)
  editCounter(input: EditCounterInput!): Counter! @join__field(graph: SYMPHONY)
  editCounterFamily(input: EditCounterFamilyInput!): CounterFamily! @join__field(graph: SYMPHONY)
  editCounterFormula(input: EditCounterFormulaInput!): CounterFormula! @join__field(graph: SYMPHONY)
  editDomain(input: EditDomainInput!): Domain! @join__field(graph: SYMPHONY)
  editEquipment(input: EditEquipmentInput!): Equipment! @join__field(graph: SYMPHONY)
  editEquipmentPort(input: EditEquipmentPortInput!): EquipmentPort! @join__field(graph: SYMPHONY)
  editEquipmentPortType(input: EditEquipmentPortTypeInput!): EquipmentPortType! @join__field(graph: SYMPHONY)
  editEquipmentType(input: EditEquipmentTypeInput!): EquipmentType! @join__field(graph: SYMPHONY)
  editEventSeverity(input: EditEventSeverityInput!): EventSeverity! @join__field(graph: SYMPHONY)
  editFlowInstance(input: EditFlowInstanceInput): FlowInstance! @join__field(graph: SYMPHONY)
  editFormula(input: EditFormulaInput!): Formula! @join__field(graph: SYMPHONY)
  editIsListable(input: EditIsListableInput!): PropertyType! @join__field(graph: SYMPHONY)
  editKpi(input: EditKpiInput!): Kpi! @join__field(graph: SYMPHONY)
  editKpiCategory(input: EditKpiCategoryInput!): KpiCategory! @join__field(graph: SYMPHONY)
  editKqi(input: EditKqiInput!): Kqi! @join__field(graph: SYMPHONY)
  editKqiCategory(input: EditKqiCategoryInput!): KqiCategory! @join__field(graph: SYMPHONY)
  editKqiComparator(input: EditKqiComparatorInput!): KqiComparator! @join__field(graph: SYMPHONY)
  editKqiPerspective(input: EditKqiPerspectiveInput!): KqiPerspective! @join__field(graph: SYMPHONY)
  editKqiSource(input: EditKqiSourceInput!): KqiSource! @join__field(graph: SYMPHONY)
  editKqiTarget(input: EditKqiTargetInput!): KqiTarget! @join__field(graph: SYMPHONY)
  editKqiTemporalFrequency(input: EditKqiTemporalFrequencyInput!): KqiTemporalFrequency! @join__field(graph: SYMPHONY)
  editLink(input: EditLinkInput!): Link! @join__field(graph: SYMPHONY)
  editLocation(input: EditLocationInput!): Location! @join__field(graph: SYMPHONY)
  editLocationType(input: EditLocationTypeInput!): LocationType! @join__field(graph: SYMPHONY)
  editLocationTypeSurveyTemplateCategories(
    """id of the location type to edit"""
    id: ID!

    """survey categories and questions we want to configure for this type"""
    surveyTemplateCategories: [SurveyTemplateCategoryInput!]!
  ): [SurveyTemplateCategory!] @join__field(graph: SYMPHONY)
  editLocationTypesIndex(
    """edit the location index to the location"""
    locationTypesIndex: [LocationTypeIndex]!
  ): [LocationType] @join__field(graph: SYMPHONY)
  editNetworkType(input: EditNetworkTypeInput!): NetworkType! @join__field(graph: SYMPHONY)
  editOrganization(input: EditOrganizationInput!): Organization! @join__field(graph: SYMPHONY)
  editParametersCatalog(parametersCatalog: [EditParameterCatalogInput]!): [ParameterCatalog!] @join__field(graph: SYMPHONY)
  editPermissionsPolicy(input: EditPermissionsPolicyInput!): PermissionsPolicy! @join__field(graph: SYMPHONY)
  editProject(input: EditProjectInput!): Project! @join__field(graph: SYMPHONY)
  editProjectType(input: EditProjectTypeInput!): ProjectType! @join__field(graph: SYMPHONY)
  editPropertyCategories(propertyCategories: [EditPropertyCategoryInput]): [PropertyCategory!] @join__field(graph: SYMPHONY)
  editPropertyType(input: EditPropertyTypeInput!): PropertyType! @join__field(graph: SYMPHONY)
  editPropertyTypeValue(input: EditPropertyTypeValueInput!): PropertyTypeValue! @join__field(graph: SYMPHONY)
  editRecommendations(input: EditRecommendationsInput!): Recommendations! @join__field(graph: SYMPHONY)
  editRecommendationsCategory(input: EditRecommendationsCategoryInput!): RecommendationsCategory! @join__field(graph: SYMPHONY)
  editRecommendationsSources(input: EditRecommendationsSourcesInput!): RecommendationsSources! @join__field(graph: SYMPHONY)
  editReportFilter(input: EditReportFilterInput!): ReportFilter! @join__field(graph: SYMPHONY)
  editResourceSpecification(input: EditResourceSpecificationInput!): ResourceSpecification! @join__field(graph: SYMPHONY)
  editResourceSpecificationItems(input: EditResourceSpecificationItemsInput!): ResourceSpecificationItems! @join__field(graph: SYMPHONY)
  editResourceSpecificationRelationship(input: EditResourceSpecificationRelationshipInput!): ResourceSpecificationRelationship! @join__field(graph: SYMPHONY)
  editResourceType(input: EditResourceTypeInput!): ResourceType! @join__field(graph: SYMPHONY)
  editResourceTypeRelationship(input: EditResourceTypeRelationshipInput!): ResourceTypeRelationship! @join__field(graph: SYMPHONY)
  editRule(input: EditRuleInput!): Rule! @join__field(graph: SYMPHONY)
  editRuleLimit(input: EditRuleLimitInput!): RuleLimit! @join__field(graph: SYMPHONY)
  editRuleType(input: EditRuleTypeInput!): RuleType! @join__field(graph: SYMPHONY)
  editService(
    """data to edit service"""
    data: ServiceEditData!
  ): Service! @join__field(graph: SYMPHONY)
  editServiceType(
    """data to edit service type"""
    data: ServiceTypeEditData!
  ): ServiceType! @join__field(graph: SYMPHONY)
  editTech(input: EditTechInput!): Tech! @join__field(graph: SYMPHONY)
  editThreshold(input: EditThresholdInput!): Threshold! @join__field(graph: SYMPHONY)
  editUser(input: EditUserInput!): User! @join__field(graph: SYMPHONY)
  editUsersGroup(input: EditUsersGroupInput!): UsersGroup! @join__field(graph: SYMPHONY)
  editVendor(input: EditVendorInput!): Vendor! @join__field(graph: SYMPHONY)
  editWorkOrder(input: EditWorkOrderInput!): WorkOrder! @join__field(graph: SYMPHONY)
  editWorkOrderType(input: EditWorkOrderTypeInput!): WorkOrderType! @join__field(graph: SYMPHONY)
  editWorkerType(input: EditWorkerTypeInput!): WorkerType! @join__field(graph: SYMPHONY)
  executeWorkOrder(id: ID!): WorkOrderExecutionResult! @join__field(graph: SYMPHONY)
  importFlowDraft(input: ImportFlowDraftInput!): FlowDraft! @join__field(graph: SYMPHONY)
  markSiteSurveyNeeded(locationId: ID!, needed: Boolean!): Location! @join__field(graph: SYMPHONY)
  moveEquipmentToPosition(
    """
    id of the equipment to that will be attached as a child to the position
    """
    equipmentId: ID!

    """id of the equipment of the position definition to attach to"""
    parentEquipmentId: ID

    """id of the position definition to attach to"""
    positionDefinitionId: ID
  ): EquipmentPosition! @join__field(graph: SYMPHONY)
  moveLocation(
    """ID of the location that will be moved"""
    locationID: ID!

    """ID of the location to be the new parent"""
    parentLocationID: ID
  ): Location! @join__field(graph: SYMPHONY)
  publishFlow(input: PublishFlowInput!): Flow! @join__field(graph: SYMPHONY)
  removeAlarmFilter(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeAlarmStatus(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeAppointment(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeComparator(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeCounter(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeCounterFamily(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeCounterFormula(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeCustomer(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeDocumentCategory(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeDomain(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeEquipment(id: ID!, workOrderId: ID): ID! @join__field(graph: SYMPHONY)
  removeEquipmentFromPosition(
    positionId: ID!

    """id of the work order to remove this equipment"""
    workOrderId: ID
  ): EquipmentPosition! @join__field(graph: SYMPHONY)
  removeEquipmentPortType(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeEquipmentType(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeEventSeverity(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeFormula(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeKpi(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeKpiCategory(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeKqi(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeKqiCategory(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeKqiComparator(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeKqiPerspective(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeKqiSource(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeKqiTarget(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeKqiTemporalFrequency(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeLink(id: ID!, workOrderId: ID): Link! @join__field(graph: SYMPHONY)
  removeLocation(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeLocationType(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeNetworkType(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeOrganization(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeParameterCatalog(entityType: ParameterCatalogEntity!, id: ID!): ID! @join__field(graph: SYMPHONY)
  removePropertyCategory(id: ID!): ID! @join__field(graph: SYMPHONY)
  removePropertyTypeValue(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeRecommendations(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeRecommendationsCategory(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeRecommendationsSources(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeResourceSpecification(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeResourceSpecificationItems(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeResourceSpecificationRelationship(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeResourceType(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeResourceTypeRelationship(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeRule(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeRuleLimit(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeRuleType(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeService(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeServiceEndpoint(serviceEndpointId: ID!): Service! @join__field(graph: SYMPHONY)
  removeServiceLink(id: ID!, linkId: ID!): Service! @join__field(graph: SYMPHONY)
  removeServicePort(id: ID!, portId: ID!): Service! @join__field(graph: SYMPHONY)
  removeServiceType(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeSiteSurvey(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeTech(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeThreshold(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeVendor(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeWorkOrder(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeWorkOrderType(id: ID!): ID! @join__field(graph: SYMPHONY)
  removeWorkerType(id: ID!): ID! @join__field(graph: SYMPHONY)
  startFlow(input: StartFlowInput!): FlowInstance! @join__field(graph: SYMPHONY)
  technicianWorkOrderCheckIn(input: TechnicianWorkOrderCheckInInput, workOrderId: ID!): WorkOrder! @join__field(graph: SYMPHONY)
  technicianWorkOrderCheckOut(input: TechnicianWorkOrderCheckOutInput!): WorkOrder! @join__field(graph: SYMPHONY)
  technicianWorkOrderUploadData(input: TechnicianWorkOrderUploadInput!): WorkOrder! @deprecated(reason: "Use `technicianWorkOrderCheckOut` instead. Will be removed on 2020-11-01") @join__field(graph: SYMPHONY)
  updateCMVersion(input: UpdateCMVersionInput!): UpdateCMVersionPayload @join__field(graph: DGRAPHSERVICE)
  updateChangeItem(input: UpdateChangeItemInput!): UpdateChangeItemPayload @join__field(graph: DGRAPHSERVICE)
  updateChangeRequest(input: UpdateChangeRequestInput!): UpdateChangeRequestPayload @join__field(graph: DGRAPHSERVICE)
  updateChangeRequestActivity(input: UpdateChangeRequestActivityInput!): UpdateChangeRequestActivityPayload @join__field(graph: DGRAPHSERVICE)
  updateComposed_of(input: UpdateComposed_ofInput!): UpdateComposed_ofPayload @join__field(graph: DGRAPHSERVICE)
  updateConfigParamTag(input: UpdateConfigParamTagInput!): UpdateConfigParamTagPayload @join__field(graph: DGRAPHSERVICE)
  updateConfigurationParameterType(input: UpdateConfigurationParameterTypeInput!): UpdateConfigurationParameterTypePayload @join__field(graph: DGRAPHSERVICE)
  updateParameter(input: UpdateParameterInput!): UpdateParameterPayload @join__field(graph: DGRAPHSERVICE)
  updateResource(input: UpdateResourceInput!): UpdateResourcePayload @join__field(graph: DGRAPHSERVICE)
  updateResourceProperty(input: UpdateResourcePropertyInput!): UpdateResourcePropertyPayload @join__field(graph: DGRAPHSERVICE)
  updateSchedulerConfig(input: UpdateSchedulerConfigInput!): UpdateSchedulerConfigPayload @join__field(graph: DGRAPHSERVICE)
  updateUserGroups(input: UpdateUserGroupsInput!): User! @join__field(graph: SYMPHONY)
}

interface NamedNode {
  """The id of the object."""
  id: ID!

  """The name of the object."""
  name: String!
}

input NearFilter {
  coordinate: PointRef!
  distance: Float!
}

type NetworkTopology {
  links: [TopologyLink!]!
  nodes: [Node!]!
}

type NetworkType implements Node {
  id: ID!
  name: String!
}

"""A connection to a list of network types."""
type NetworkTypeConnection {
  """A list of network types edges."""
  edges: [NetworkTypeEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total network types of projects in all pages."""
  totalCount: Int!
}

"""A network types edge in a connection."""
type NetworkTypeEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The network types at the end of the edge."""
  node: NetworkType
}

input NetworkTypeFilterInput {
  filterType: NetworkTypeFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum NetworkTypeFilterType {
  NAME
}

"""Ordering options for network types connections."""
input NetworkTypeOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order network types by."""
  field: NetworkTypeOrderField
}

"""Properties by which network types connections can be ordered."""
enum NetworkTypeOrderField {
  """Order network types by creation time."""
  CREATED_AT

  """Order network types by name."""
  NAME

  """Order network types by update time."""
  UPDATED_AT
}

"""An object with an ID"""
interface Node {
  """The id of the object."""
  id: ID!
}

enum OperationalSubStatus {
  NOT_WORKING
  WORKING
}

"""
Possible directions in which to order a list of items when provided an `orderBy` argument.
"""
enum OrderDirection {
  """Specifies an ascending order for a given `orderBy` argument."""
  ASC

  """Specifies a descending order for a given `orderBy` argument."""
  DESC
}

type Organization implements Node {
  description: String!
  id: ID!
  name: String!
}

"""A connection to a list of Organization."""
type OrganizationConnection {
  """A list of Organization edges."""
  edges: [OrganizationEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total Organization of projects in all pages."""
  totalCount: Int!
}

"""A Organization edge in a connection."""
type OrganizationEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The Organization at the end of the edge."""
  node: Organization
}

input OrganizationFilterInput {
  filterType: OrganizationFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum OrganizationFilterType {
  DESCRIPTION
  ID
  NAME
}

"""Ordering options for Organization connections."""
input OrganizationOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order Organization by."""
  field: OrganizationOrderField
}

"""Properties by which Organization connections can be ordered."""
enum OrganizationOrderField {
  """Order Organization by creation time."""
  CREATED_AT

  """Order Organization by name."""
  NAME

  """Order Organization by update time."""
  UPDATED_AT
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating backwards, the cursor to continue."""
  endCursor: Cursor

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating forwards, the cursor to continue."""
  startCursor: Cursor
}

type ParallelBlock {
  entryPoint: EntryPoint!
  exitPoint: ExitPoint!
  internalExitPoint: ExitPoint!
}

type Parameter {
  booleanValue: Boolean
  floatValue: Float
  id: ID!
  intValue: Int
  latitudeValue: Float
  longitudeValue: Float
  parameterType(filter: ConfigurationParameterTypeFilter): ConfigurationParameterType!
  previous(filter: ParameterFilter): Parameter
  rangeFromValue: Float
  rangeToValue: Float
  stringValue: String
  versionCM(filter: CMVersionFilter, first: Int, offset: Int, order: CMVersionOrder): [CMVersion]!
  versionCMAggregate(filter: CMVersionFilter): CMVersionAggregateResult
}

type ParameterAggregateResult {
  count: Int
  floatValueAvg: Float
  floatValueMax: Float
  floatValueMin: Float
  floatValueSum: Float
  intValueAvg: Float
  intValueMax: Int
  intValueMin: Int
  intValueSum: Int
  latitudeValueAvg: Float
  latitudeValueMax: Float
  latitudeValueMin: Float
  latitudeValueSum: Float
  longitudeValueAvg: Float
  longitudeValueMax: Float
  longitudeValueMin: Float
  longitudeValueSum: Float
  rangeFromValueAvg: Float
  rangeFromValueMax: Float
  rangeFromValueMin: Float
  rangeFromValueSum: Float
  rangeToValueAvg: Float
  rangeToValueMax: Float
  rangeToValueMin: Float
  rangeToValueSum: Float
  stringValueMax: String
  stringValueMin: String
}

type ParameterCatalog implements Node {
  id: ID!
  index: Int
  isDisabled: Boolean
  name: String
  propertyCategories: [PropertyCategory]!
}

"""A connection to a list of Parameter Catalog"""
type ParameterCatalogConnection {
  """A list of Parameter Catalog edges."""
  edges: [ParameterCatalogEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of Parameter Catalog in all pages."""
  totalCount: Int!
}

"""A Parameter Catalog edge in a connection."""
type ParameterCatalogEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The Parameter Catalog at the end of the edge."""
  node: ParameterCatalog
}

enum ParameterCatalogEntity {
  PROPERTY_CATEGORY
}

input ParameterFilter {
  and: [ParameterFilter]
  has: [ParameterHasFilter]
  id: [ID!]
  not: ParameterFilter
  or: [ParameterFilter]
}

enum ParameterHasFilter {
  booleanValue
  floatValue
  intValue
  latitudeValue
  longitudeValue
  parameterType
  previous
  rangeFromValue
  rangeToValue
  stringValue
  versionCM
}

enum ParameterKind {
  bool
  date
  datetime_local
  email
  enum
  float
  gps_location
  int
  range
  string
}

input ParameterOrder {
  asc: ParameterOrderable
  desc: ParameterOrderable
  then: ParameterOrder
}

enum ParameterOrderable {
  floatValue
  intValue
  latitudeValue
  longitudeValue
  rangeFromValue
  rangeToValue
  stringValue
}

input ParameterPatch {
  booleanValue: Boolean
  floatValue: Float
  intValue: Int
  latitudeValue: Float
  longitudeValue: Float
  parameterType: ConfigurationParameterTypeRef
  previous: ParameterRef
  rangeFromValue: Float
  rangeToValue: Float
  stringValue: String
  versionCM: [CMVersionRef]
}

input ParameterRef {
  booleanValue: Boolean
  floatValue: Float
  id: ID
  intValue: Int
  latitudeValue: Float
  longitudeValue: Float
  parameterType: ConfigurationParameterTypeRef
  previous: ParameterRef
  rangeFromValue: Float
  rangeToValue: Float
  stringValue: String
  versionCM: [CMVersionRef]
}

input ParentPropertyTypeValueInput {
  parentPropertyType: ID
  parentPropertyTypeValue: String
}

type PermissionSettings {
  adminPolicy: AdministrativePolicy!
  assurancePolicy: AssurancePolicy!
  automationPolicy: AutomationPolicy!
  inventoryPolicy: InventoryPolicy!
  workforcePolicy: WorkforcePolicy!
}

enum PermissionValue {
  BY_CONDITION
  NO
  YES
}

type PermissionsPolicy implements Node {
  description: String
  groups: [UsersGroup!]!
  id: ID!
  isGlobal: Boolean!
  isMulticontractor: Boolean!
  name: String!
  policy: SystemPolicy!
}

"""A connection to a list of permissions policies."""
type PermissionsPolicyConnection {
  """A list of permissions policies type edges."""
  edges: [PermissionsPolicyEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of permission policies in all pages."""
  totalCount: Int!
}

"""A permission policy type edge in a connection."""
type PermissionsPolicyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The permission policy type at the end of the edge."""
  node: PermissionsPolicy
}

input PermissionsPolicyFilterInput {
  filterType: PermissionsPolicyFilterType!
  maxDepth: Int = 5
  operator: FilterOperator!
  stringValue: String
}

"""what filters should we apply on permissionsPolicy"""
enum PermissionsPolicyFilterType {
  PERMISSIONS_POLICY_NAME
}

type PermissionsPolicySearchResult {
  count: Int!
  permissionsPolicies: [PermissionsPolicy]!
}

enum PlanningSubStatus {
  ACTIVATED
  DESACTIVATED
}

type Point {
  latitude: Float!
  longitude: Float!
}

input PointGeoFilter {
  near: NearFilter
  within: WithinFilter
}

type PointList {
  points: [Point!]!
}

input PointListRef {
  points: [PointRef!]!
}

input PointRef {
  latitude: Float!
  longitude: Float!
}

type Polygon {
  coordinates: [PointList!]!
}

input PolygonGeoFilter {
  contains: ContainsFilter
  intersects: IntersectsFilter
  near: NearFilter
  within: WithinFilter
}

input PolygonRef {
  coordinates: [PointListRef!]!
}

input PortFilterInput {
  boolValue: Boolean
  filterType: PortFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  propertyValue: PropertyTypeInput
  stringSet: [String!]
  stringValue: String
}

"""what filters should we apply on ports"""
enum PortFilterType {
  LOCATION_INST
  LOCATION_INST_EXTERNAL_ID
  PORT_DEF
  PORT_INST_EQUIPMENT
  PORT_INST_HAS_LINK
  PROPERTY
  SERVICE_INST
}

type PortSearchResult {
  count: Int!
  ports: [EquipmentPort]!
}

type Project implements NamedNode & Node {
  comments: [Comment]!
  createTime: Time!
  createdBy: User
  description: String
  id: ID!
  location: Location
  name: String!
  numberOfWorkOrders: Int!
  priority: ProjectPriority!
  properties: [Property!]!
  template: ProjectTemplate
  type: ProjectType!
  workOrders: [WorkOrder!]!
}

"""A connection to a list of projects."""
type ProjectConnection {
  """A list of project edges."""
  edges: [ProjectEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of projects in all pages."""
  totalCount: Int!
}

"""A project edge in a connection."""
type ProjectEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The project at the end of the edge."""
  node: Project
}

input ProjectFilterInput {
  filterType: ProjectFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  propertyValue: PropertyTypeInput
  stringSet: [String!]
  stringValue: String
  timeValue: Time
}

enum ProjectFilterType {
  LOCATION_INST
  PROJECT_CREATION_DATE
  PROJECT_NAME
  PROJECT_OWNED_BY
  PROJECT_PRIORITY
  PROJECT_TYPE
  PROPERTY
}

"""Ordering options for project connections."""
input ProjectOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order projects by."""
  field: ProjectOrderField
}

"""Properties by which project connections can be ordered."""
enum ProjectOrderField {
  """Order projects by creation time."""
  CREATED_AT

  """Order projects by name."""
  NAME

  """Order projects by priority."""
  PRIORITY

  """Order projects by property type."""
  PROPERTY

  """Order projects by update time."""
  UPDATED_AT
}

enum ProjectPriority {
  HIGH
  LOW
  MEDIUM
  NONE
  URGENT
}

type ProjectTemplate {
  description: String
  name: String!
  properties: [PropertyType]!
  workOrders: [WorkOrderDefinition]!
}

type ProjectType implements Node {
  description: String
  id: ID!
  name: String!
  numberOfProjects: Int!
  projects: [Project!]!
  properties: [PropertyType!]!
  workOrders: [WorkOrderDefinition]!
}

"""A connection to a list of project types."""
type ProjectTypeConnection {
  """A list of project type edges."""
  edges: [ProjectTypeEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of project types in all pages."""
  totalCount: Int!
}

"""A project type edge in a connection."""
type ProjectTypeEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The project type at the end of the edge."""
  node: ProjectType
}

"""Model for properties group by property categories"""
type PropertiesByCategories {
  id: ID
  name: String
  properties: [Property]
  propertyType: [PropertyType]
}

input PropertiesByCategoryFilterInput {
  filterType: PropertiesByCategoryFilterType!
  idSet: [ID!]
  intValue: Int
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

"""what type of properties category we filter about"""
enum PropertiesByCategoryFilterType {
  LOCATION_ID
  PROPERTY_CATEGORY_ID
  PROPERTY_CATEGORY_IS_NIL
}

type Property implements Node {
  booleanValue: Boolean
  dependenceProperties: [Property!]
  floatValue: Float
  id: ID!
  intValue: Int
  latitudeValue: Float
  longitudeValue: Float
  nodeValue: NamedNode
  propertyType: PropertyType!
  propertyTypeValue: PropertyTypeValue
  rangeFromValue: Float
  rangeToValue: Float
  rawValue: String
  stringValue: String
}

type PropertyCategory implements Node {
  id: ID!
  index: Int
  name: String
  numberOfProperties: Int
}

type PropertyCategoryCUD {
  create: PropertyCategoryPermissionRule
  delete: PropertyCategoryPermissionRule
  read: PropertyCategoryPermissionRule
  update: PropertyCategoryPermissionRule
}

input PropertyCategoryCUDInput {
  create: PropertyCategoryPermissionRuleInput
  delete: PropertyCategoryPermissionRuleInput
  read: PropertyCategoryPermissionRuleInput
  update: PropertyCategoryPermissionRuleInput
}

"""A connection to a list of Property Category."""
type PropertyCategoryConnection {
  """A list of Property Category edges."""
  edges: [PropertyCategoryEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of Property Category in all pages."""
  totalCount: Int!
}

"""A Property Category edge in a connection."""
type PropertyCategoryEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The Property Category at the end of the edge."""
  node: PropertyCategory
}

"""Ordering options for property category connections."""
input PropertyCategoryOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order property category by."""
  field: PropertyCategoryOrderField
}

"""Properties by which property categories connections can be ordered."""
enum PropertyCategoryOrderField {
  """Order Property Category by index."""
  INDEX

  """Order Property Category by name."""
  NAME
}

type PropertyCategoryPermissionRule {
  isAllowed: PermissionValue!
  propertyCategoryIds: [ID!]
}

input PropertyCategoryPermissionRuleInput {
  isAllowed: PermissionValue!
  propertyCategoryIds: [ID!]
}

enum PropertyEntity {
  EQUIPMENT
  LINK
  LOCATION
  PORT
  PROJECT
  SERVICE
  WORK_ORDER
}

input PropertyInput {
  booleanValue: Boolean
  dependenceProperties: [PropertyInput!]
  floatValue: Float
  id: ID
  intValue: Int
  isEditable: Boolean
  isInstanceProperty: Boolean
  latitudeValue: Float
  longitudeValue: Float
  nodeIDValue: ID
  propertyTypeID: ID!
  propertyTypeValueID: ID
  rangeFromValue: Float
  rangeToValue: Float
  stringValue: String
}

enum PropertyKind {
  bool
  date
  datetime_local
  email
  enum
  float
  gps_location
  int
  node
  range
  string
}

type PropertyType implements Node {
  booleanValue: Boolean
  category: String
  dependencePropertyTypes: [PropertyType]!
  externalId: String
  floatValue: Float
  id: ID!
  index: Int
  intValue: Int
  isDeleted: Boolean
  isEditable: Boolean
  isInstanceProperty: Boolean
  isListable: Boolean
  isMandatory: Boolean
  latitudeValue: Float
  longitudeValue: Float
  name: String!
  nodeType: String
  parentPropertyType: PropertyType
  propertyCategory: PropertyCategory
  propertyTypeValues: [PropertyTypeValue!]
  rangeFromValue: Float
  rangeToValue: Float
  rawValue: String
  stringValue: String
  type: PropertyKind!
}

input PropertyTypeInput {
  booleanValue: Boolean
  category: String
  dependencePropertyTypes: [PropertyTypeInput]
  externalId: String
  floatValue: Float
  id: ID
  index: Int
  intValue: Int
  isDeleted: Boolean
  isEditable: Boolean
  isInstanceProperty: Boolean
  isListable: Boolean
  isMandatory: Boolean
  latitudeValue: Float
  longitudeValue: Float
  name: String!
  nodeType: String
  propertyCategoryID: ID
  propertyTypeValues: [AddPropertyTypeValueInput]
  rangeFromValue: Float
  rangeToValue: Float
  stringValue: String
  type: PropertyKind!
}

type PropertyTypeValue implements Node {
  id: ID!
  isDeleted: Boolean
  name: String!
  parentPropertyTypeValue: [PropertyTypeValue]
  propertyType: PropertyType
}

"""A connection to a list of kpi's."""
type PropertyTypeValueConnection {
  """A list of kpi's edges."""
  edges: [PropertyTypeValueEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total kpi's of projects in all pages."""
  totalCount: Int!
}

"""A kpi's edge in a connection."""
type PropertyTypeValueEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The kpi's at the end of the edge."""
  node: PropertyTypeValue
}

input PropertyTypeValueFilterInput {
  filterType: PropertyTypeValueFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum PropertyTypeValueFilterType {
  NAME
}

"""Ordering options for propertyTypeValues connections."""
input PropertyTypeValueOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order kpi's by."""
  field: PropertyTypeValueOrderField
}

"""Properties by which PropertyTypeValues connections can be ordered."""
enum PropertyTypeValueOrderField {
  """Order propertyTypeValue by creation time."""
  CREATED_AT

  """Order propertyTypeValue by name."""
  NAME

  """Order propertyTypeValue by update time."""
  UPDATED_AT
}

input PublishFlowInput {
  cmType: FlowCMType
  flowDraftID: ID!
  flowInstancesPolicy: FlowNewInstancesPolicy!
}

type PythonPackage {
  hasBreakingChange: Boolean!
  uploadTime: Time!
  version: String!
  whlFileKey: String!
}

type Query {
  """A list of Recommendations."""
  Recommendations(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned counters."""
    filterBy: [RecommendationsFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned counters."""
    orderBy: RecommendationsOrder
  ): RecommendationsConnection! @join__field(graph: SYMPHONY)

  """A list of RecommendationsCategories."""
  RecommendationsCategories(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned counters."""
    filterBy: [RecommendationsCategoryFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned counters."""
    orderBy: RecommendationsCategoryOrder
  ): RecommendationsCategoryConnection! @join__field(graph: SYMPHONY)

  """A list of RecommendationsSources."""
  RecommendationsSources(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned counters."""
    filterBy: [RecommendationsSourcesFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned counters."""
    orderBy: RecommendationsSourcesOrder
  ): RecommendationsSourcesConnection! @join__field(graph: SYMPHONY)
  actionType(id: ActionTypeId!): ActionType @join__field(graph: SYMPHONY)
  aggregateCMVersion(filter: CMVersionFilter): CMVersionAggregateResult @join__field(graph: DGRAPHSERVICE)
  aggregateChangeItem(filter: ChangeItemFilter): ChangeItemAggregateResult @join__field(graph: DGRAPHSERVICE)
  aggregateChangeRequest(filter: ChangeRequestFilter): ChangeRequestAggregateResult @join__field(graph: DGRAPHSERVICE)
  aggregateChangeRequestActivity(filter: ChangeRequestActivityFilter): ChangeRequestActivityAggregateResult @join__field(graph: DGRAPHSERVICE)
  aggregateComposed_of(filter: Composed_ofFilter): Composed_ofAggregateResult @join__field(graph: DGRAPHSERVICE)
  aggregateConfigParamTag(filter: ConfigParamTagFilter): ConfigParamTagAggregateResult @join__field(graph: DGRAPHSERVICE)
  aggregateConfigurationParameterType(filter: ConfigurationParameterTypeFilter): ConfigurationParameterTypeAggregateResult @join__field(graph: DGRAPHSERVICE)
  aggregateParameter(filter: ParameterFilter): ParameterAggregateResult @join__field(graph: DGRAPHSERVICE)
  aggregateResource(filter: ResourceFilter): ResourceAggregateResult @join__field(graph: DGRAPHSERVICE)
  aggregateResourceProperty(filter: ResourcePropertyFilter): ResourcePropertyAggregateResult @join__field(graph: DGRAPHSERVICE)
  aggregateSchedulerConfig(filter: SchedulerConfigFilter): SchedulerConfigAggregateResult @join__field(graph: DGRAPHSERVICE)

  """A list of AlarmFilter."""
  alarmFilters(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned counters."""
    filterBy: [AlarmFilterFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned counters."""
    orderBy: AlarmFilterOrder
  ): AlarmFilterConnection! @join__field(graph: SYMPHONY)

  """A list of alarmStatus."""
  alarmStatus(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned alarmStatus."""
    filterBy: [AlarmStatusFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned alarmStatus."""
    orderBy: AlarmStatusOrder
  ): AlarmStatusConnection! @join__field(graph: SYMPHONY)
  appointments(after: Cursor, before: Cursor, first: Int, last: Int, slotFilterBy: SlotFilterInput): AppointmentConnection! @join__field(graph: SYMPHONY)

  """A list of comparator."""
  comparators(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned comparator."""
    filterBy: [ComparatorFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned comparator."""
    orderBy: ComparatorOrder
  ): ComparatorConnection! @join__field(graph: SYMPHONY)

  """A list of counterFamilies."""
  counterFamilies(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned counterFamilies."""
    filterBy: [CounterFamilyFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned counterFamilies."""
    orderBy: CounterFamilyOrder
  ): CounterFamilyConnection! @join__field(graph: SYMPHONY)

  """A list of counters."""
  counters(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned counters."""
    filterBy: [CounterFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned counters."""
    orderBy: CounterOrder
  ): CounterConnection! @join__field(graph: SYMPHONY)
  customers(after: Cursor, before: Cursor, first: Int, last: Int): CustomerConnection @join__field(graph: SYMPHONY)
  documentCategories(
    after: Cursor
    before: Cursor
    first: Int
    last: Int

    """Filter by location type ID"""
    locationTypeID: ID
  ): DocumentCategoryConnection @join__field(graph: SYMPHONY)

  """A list of domains."""
  domains(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned domains."""
    filterBy: [DomainFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned domains."""
    orderBy: DomainOrder
  ): DomainConnection! @join__field(graph: SYMPHONY)

  """Fetches end to end path of links"""
  endToEndPath(
    """find to end to end path containing this link"""
    linkId: ID

    """find to end to end path containing this port"""
    portId: ID
  ): EndToEndPath @join__field(graph: SYMPHONY)
  equipmentPortDefinitions(after: Cursor, before: Cursor, first: Int, last: Int): EquipmentPortDefinitionConnection! @join__field(graph: SYMPHONY)
  equipmentPortTypes(after: Cursor, before: Cursor, first: Int, last: Int): EquipmentPortTypeConnection! @join__field(graph: SYMPHONY)
  equipmentPorts(after: Cursor, before: Cursor, filterBy: [PortFilterInput!], first: Int, last: Int): EquipmentPortConnection! @join__field(graph: SYMPHONY)
  equipmentTypes(after: Cursor, before: Cursor, first: Int, last: Int): EquipmentTypeConnection! @join__field(graph: SYMPHONY)

  """A list of equipment."""
  equipments(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned equipment."""
    filterBy: [EquipmentFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned equipment."""
    orderBy: EquipmentOrder
  ): EquipmentConnection! @join__field(graph: SYMPHONY)

  """A list of eventSeverities."""
  eventSeverities(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned eventSeverities."""
    filterBy: [EventSeverityFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned eventSeverities."""
    orderBy: EventSeverityOrder
  ): EventSeverityConnection! @join__field(graph: SYMPHONY)
  flowDrafts(
    after: Cursor
    before: Cursor
    first: Int
    last: Int

    """Filter flowDrafts by case sensitive name."""
    name: String
  ): FlowDraftConnection! @join__field(graph: SYMPHONY)
  flowInstances(after: Cursor, before: Cursor, filterBy: [FlowInstanceFilterInput!], first: Int, last: Int, orderBy: FlowInstanceOrder): FlowInstanceConnection! @join__field(graph: SYMPHONY)
  flows(after: Cursor, before: Cursor, filterBy: [FlowFilterInput!], first: Int, last: Int, orderBy: FlowOrder): FlowConnection! @join__field(graph: SYMPHONY)

  """A list of formulas."""
  formulas(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned formulas."""
    filterBy: [FormulaFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned formulas."""
    orderBy: FormulaOrder
  ): FormulaConnection! @join__field(graph: SYMPHONY)
  getCMVersion(id: ID!): CMVersion @join__field(graph: DGRAPHSERVICE)
  getChangeItem(id: ID!): ChangeItem @join__field(graph: DGRAPHSERVICE)
  getChangeRequest(id: ID!): ChangeRequest @join__field(graph: DGRAPHSERVICE)
  getChangeRequestActivity(id: ID!): ChangeRequestActivity @join__field(graph: DGRAPHSERVICE)
  getConfigParamTag(id: ID!): ConfigParamTag @join__field(graph: DGRAPHSERVICE)
  getConfigurationParameterType(id: ID!): ConfigurationParameterType @join__field(graph: DGRAPHSERVICE)
  getParameter(id: ID!): Parameter @join__field(graph: DGRAPHSERVICE)
  getResource(id: ID, name: String): Resource @join__field(graph: DGRAPHSERVICE)
  getResourceProperty(id: ID!): ResourceProperty @join__field(graph: DGRAPHSERVICE)
  getSchedulerConfig(id: ID!): SchedulerConfig @join__field(graph: DGRAPHSERVICE)

  """A list of kpiCategories."""
  kpiCategories(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned kpiCategoriess."""
    filterBy: [KpiCategoryFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned kpiCategoriess."""
    orderBy: KpiCategoryOrder
  ): KpiCategoryConnection! @join__field(graph: SYMPHONY)

  """A list of kpis."""
  kpis(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned kpis."""
    filterBy: [KpiFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned kpis."""
    orderBy: KpiOrder
  ): KpiConnection! @join__field(graph: SYMPHONY)

  """A list of kqiCategories."""
  kqiCategories(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned kqiCategories."""
    filterBy: [KqiCategoryFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned kqiCategories."""
    orderBy: KqiCategoryOrder
  ): KqiCategoryConnection! @join__field(graph: SYMPHONY)

  """A list of kqiPerspectives."""
  kqiPerspectives(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned kqiPerspectives."""
    filterBy: [KqiPerspectiveFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned kqiPerspectives."""
    orderBy: KqiPerspectiveOrder
  ): KqiPerspectiveConnection! @join__field(graph: SYMPHONY)

  """A list of kqiSource."""
  kqiSources(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned kqiSource."""
    filterBy: [KqiSourceFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned kqiSource."""
    orderBy: KqiSourceOrder
  ): KqiSourceConnection! @join__field(graph: SYMPHONY)

  """A list of kqiTarget."""
  kqiTargets(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned kqiTarget."""
    filterBy: [KqiTargetFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned kqiTarget."""
    orderBy: KqiTargetOrder
  ): KqiTargetConnection! @join__field(graph: SYMPHONY)

  """A list of kqiTemporalFrequency."""
  kqiTemporalFrequencies(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned kqiTemporalFrequency."""
    filterBy: [KqiTemporalFrequencyFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned kqiTemporalFrequency."""
    orderBy: KqiTemporalFrequencyOrder
  ): KqiTemporalFrequencyConnection! @join__field(graph: SYMPHONY)

  """A list of Kqi."""
  kqis(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned counters."""
    filterBy: [KqiFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned counters."""
    orderBy: KqiOrder
  ): KqiConnection! @join__field(graph: SYMPHONY)
  latestPythonPackage: LatestPythonPackageResult @join__field(graph: SYMPHONY)
  links(after: Cursor, before: Cursor, filterBy: [LinkFilterInput!], first: Int, last: Int): LinkConnection! @join__field(graph: SYMPHONY)
  locationTypes(after: Cursor, before: Cursor, first: Int, last: Int): LocationTypeConnection @join__field(graph: SYMPHONY)

  """A list of locations."""
  locations(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned locations."""
    filterBy: [LocationFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Filter location containing case insensitive name."""
    name: String

    """Filter by locations needing site survey."""
    needsSiteSurvey: Boolean

    """Filter to only root locations."""
    onlyTopLevel: Boolean

    """Ordering options for the returned locations."""
    orderBy: LocationOrder

    """Filter to only locations under location types."""
    types: [ID!]
  ): LocationConnection @join__field(graph: SYMPHONY)

  """Fetches current viewer."""
  me: Viewer @join__field(graph: SYMPHONY)
  nearestSites(first: Int! = 10, latitude: Float!, longitude: Float!): [Location!]! @join__field(graph: SYMPHONY)

  """A list of networkTypes."""
  networkTypes(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned networkTypes."""
    filterBy: [NetworkTypeFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned networkTypes."""
    orderBy: NetworkTypeOrder
  ): NetworkTypeConnection! @join__field(graph: SYMPHONY)

  """Fetches an object given its ID."""
  node(
    """ID of the object."""
    id: ID!
  ): Node @join__field(graph: SYMPHONY)

  """A list of organization."""
  organizations(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned organization."""
    filterBy: [OrganizationFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned organization."""
    orderBy: OrganizationOrder
  ): OrganizationConnection! @join__field(graph: SYMPHONY)
  parametersCatalog(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ParameterCatalogConnection! @join__field(graph: SYMPHONY)
  permissionsPolicies(after: Cursor, before: Cursor, filterBy: [PermissionsPolicyFilterInput!], first: Int, last: Int): PermissionsPolicyConnection @join__field(graph: SYMPHONY)
  possibleProperties(entityType: PropertyEntity!): [PropertyType!]! @join__field(graph: SYMPHONY)
  projectTypes(after: Cursor, before: Cursor, first: Int, last: Int): ProjectTypeConnection @join__field(graph: SYMPHONY)

  """A list of projects."""
  projects(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned projects."""
    filterBy: [ProjectFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned projects."""
    orderBy: ProjectOrder

    """Property direction for ordering projects."""
    propertyOrder: String

    """Property value for ordering projects."""
    propertyValue: String
  ): ProjectConnection! @join__field(graph: SYMPHONY)
  propertiesByCategories(filterBy: [PropertiesByCategoryFilterInput!]): [PropertiesByCategories]! @join__field(graph: SYMPHONY)
  propertyCategories(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    orderBy: PropertyCategoryOrder
  ): PropertyCategoryConnection! @join__field(graph: SYMPHONY)

  """A list of propertyTypeValue."""
  propertyTypeValues(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned networkTypes."""
    filterBy: [PropertyTypeValueFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned networkTypes."""
    orderBy: PropertyTypeValueOrder
  ): PropertyTypeValueConnection! @join__field(graph: SYMPHONY)
  pythonPackages: [PythonPackage!]! @join__field(graph: SYMPHONY)
  queryCMVersion(filter: CMVersionFilter, first: Int, offset: Int, order: CMVersionOrder): [CMVersion] @join__field(graph: DGRAPHSERVICE)
  queryChangeItem(filter: ChangeItemFilter, first: Int, offset: Int, order: ChangeItemOrder): [ChangeItem] @join__field(graph: DGRAPHSERVICE)
  queryChangeRequest(filter: ChangeRequestFilter, first: Int, offset: Int, order: ChangeRequestOrder): [ChangeRequest] @join__field(graph: DGRAPHSERVICE)
  queryChangeRequestActivity(filter: ChangeRequestActivityFilter, first: Int, offset: Int, order: ChangeRequestActivityOrder): [ChangeRequestActivity] @join__field(graph: DGRAPHSERVICE)
  queryComposed_of(filter: Composed_ofFilter, first: Int, offset: Int): [Composed_of] @join__field(graph: DGRAPHSERVICE)
  queryConfigParamTag(filter: ConfigParamTagFilter, first: Int, offset: Int, order: ConfigParamTagOrder): [ConfigParamTag] @join__field(graph: DGRAPHSERVICE)
  queryConfigurationParameterType(filter: ConfigurationParameterTypeFilter, first: Int, offset: Int, order: ConfigurationParameterTypeOrder): [ConfigurationParameterType] @join__field(graph: DGRAPHSERVICE)
  queryParameter(filter: ParameterFilter, first: Int, offset: Int, order: ParameterOrder): [Parameter] @join__field(graph: DGRAPHSERVICE)
  queryResource(filter: ResourceFilter, first: Int, offset: Int, order: ResourceOrder): [Resource] @join__field(graph: DGRAPHSERVICE)
  queryResourceProperty(filter: ResourcePropertyFilter, first: Int, offset: Int, order: ResourcePropertyOrder): [ResourceProperty] @join__field(graph: DGRAPHSERVICE)
  querySchedulerConfig(filter: SchedulerConfigFilter, first: Int, offset: Int, order: SchedulerConfigOrder): [SchedulerConfig] @join__field(graph: DGRAPHSERVICE)
  reportFilters(entity: FilterEntity!): [ReportFilter!]! @join__field(graph: SYMPHONY)

  """A list of resourceSpecificationItems."""
  resourceSpecificationItems(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor
    filterBy: [ResourceSpecificationItemsFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): ResourceSpecificationItemsConnection! @join__field(graph: SYMPHONY)

  """A list of resourceSpecificationRelationships."""
  resourceSpecificationRelationships(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor
    filterBy: [ResourceSpecificationRelationshipFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned resourceSpecificationRelationships."""
    orderBy: ResourceSpecificationRelationshipOrder
  ): ResourceSpecificationRelationshipConnection! @join__field(graph: SYMPHONY)

  """A list of resourceSpecifications."""
  resourceSpecifications(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor
    filterBy: [ResourceSpecificationFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned resourceSpecifications."""
    orderBy: ResourceSpecificationOrder
  ): ResourceSpecificationConnection! @join__field(graph: SYMPHONY)

  """A list of resourceTypeRelationships."""
  resourceTypeRelationships(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor
    filterBy: [ResourceTypeRelationshipFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned resourceTypeRelationships."""
    orderBy: ResourceTypeRelationshipOrder
  ): ResourceTypeRelationshipConnection! @join__field(graph: SYMPHONY)

  """A list of resourceTypes."""
  resourceTypes(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor
    filterBy: [ResourceTypeFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned resourceTypes."""
    orderBy: ResourceTypeOrder
  ): ResourceTypeConnection! @join__field(graph: SYMPHONY)

  """A list of ruleTypes."""
  ruleTypes(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned ruleTypes."""
    filterBy: [RuleTypeFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned ruleTypes."""
    orderBy: RuleTypeOrder
  ): RuleTypeConnection! @join__field(graph: SYMPHONY)
  searchForNode(after: Cursor, before: Cursor, first: Int = 10, last: Int, name: String!): SearchNodesConnection! @join__field(graph: SYMPHONY)
  serviceTypes(after: Cursor, before: Cursor, first: Int, last: Int): ServiceTypeConnection @join__field(graph: SYMPHONY)
  services(after: Cursor, before: Cursor, filterBy: [ServiceFilterInput!], first: Int, last: Int): ServiceConnection! @join__field(graph: SYMPHONY)
  surveys: [Survey!]! @join__field(graph: SYMPHONY)

  """A list of techs."""
  techs(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned techs."""
    filterBy: [TechFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned techs."""
    orderBy: TechOrder
  ): TechConnection! @join__field(graph: SYMPHONY)

  """A list of thresholds."""
  thresholds(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned counters."""
    filterBy: [ThresholdFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned counters."""
    orderBy: ThresholdOrder
  ): ThresholdConnection! @join__field(graph: SYMPHONY)
  triggerType(id: TriggerTypeId!): TriggerType @join__field(graph: SYMPHONY)
  user(authID: String!): User @join__field(graph: SYMPHONY)
  users(after: Cursor, before: Cursor, filterBy: [UserFilterInput!], first: Int, last: Int): UserConnection @join__field(graph: SYMPHONY)
  usersAvailability(duration: Float!, filterBy: [UserFilterInput!], regularHours: RegularHoursInput!, slotFilterBy: SlotFilterInput!): [UserAvailability!] @join__field(graph: SYMPHONY)
  usersGroups(after: Cursor, before: Cursor, filterBy: [UsersGroupFilterInput!], first: Int, last: Int): UsersGroupConnection @join__field(graph: SYMPHONY)

  """A list of vendors."""
  vendors(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned vendors."""
    filterBy: [VendorFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned vendors."""
    orderBy: VendorOrder
  ): VendorConnection! @join__field(graph: SYMPHONY)
  vertex(id: ID!): Vertex @join__field(graph: SYMPHONY)
  workOrderTypes(after: Cursor, before: Cursor, first: Int, last: Int): WorkOrderTypeConnection! @join__field(graph: SYMPHONY)

  """A list of work orders."""
  workOrders(
    """Returns the elements in the list that come after the specified cursor."""
    after: Cursor

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """Filtering options for the returned work orders."""
    filterBy: [WorkOrderFilterInput!]

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int

    """Ordering options for the returned work orders."""
    orderBy: WorkOrderOrder
  ): WorkOrderConnection! @join__field(graph: SYMPHONY)
  workerTypes(after: Cursor, before: Cursor, first: Int, last: Int): WorkerTypeConnection! @join__field(graph: SYMPHONY)
}

type Recommendations implements Node {
  alarmType: String!
  command: String
  externalID: String!
  id: ID!
  longDescription: String!
  priority: Int!
  recommendationsCategory: RecommendationsCategory!
  recommendationsSources: RecommendationsSources!
  resource: String!
  runbook: String
  shortDescription: String!
  status: Boolean!
  used: Int
  userApprobed: User
  userCreate: User!
  vendor: Vendor!
}

type RecommendationsCategory implements Node {
  id: ID!
  name: String!
  recommendations: [Recommendations!]
}

"""A connection to a list of RecommendationsCategory."""
type RecommendationsCategoryConnection {
  """A list of RecommendationsCategory edges."""
  edges: [RecommendationsCategoryEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total RecommendationsCategory of projects in all pages."""
  totalCount: Int!
}

"""A RecommendationsCategory edge in a connection."""
type RecommendationsCategoryEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The RecommendationsCategory at the end of the edge."""
  node: RecommendationsCategory
}

input RecommendationsCategoryFilterInput {
  filterType: RecommendationsCategoryFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum RecommendationsCategoryFilterType {
  NAME
}

"""Ordering options for RecommendationsCategory connections."""
input RecommendationsCategoryOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order RecommendationsCategory by."""
  field: RecommendationsCategoryOrderField
}

"""
Properties by which RecommendationsCategory connections can be ordered.
"""
enum RecommendationsCategoryOrderField {
  """Order RecommendationsCategory by creation time."""
  CREATED_AT

  """Order RecommendationsCategory by name."""
  NAME

  """Order RecommendationsCategory by update time."""
  UPDATED_AT
}

"""A connection to a list of Recommendations."""
type RecommendationsConnection {
  """A list of Recommendations edges."""
  edges: [RecommendationsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total Recommendations of projects in all pages."""
  totalCount: Int!
}

"""A Recommendations edge in a connection."""
type RecommendationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The Recommendations at the end of the edge."""
  node: Recommendations
}

input RecommendationsFilterInput {
  boolValue: Boolean
  filterType: RecommendationsFilterType!
  idSet: [ID!]
  intValue: Int
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum RecommendationsFilterType {
  ALARMTYPE
  COMMAND
  EXTERNALID
  LONGDESCRIPTION
  PRIORITY
  RECOMMENDATIONSCATEGORY
  RECOMMENDATIONSSOURCE
  RESOURCE
  RUNBOOK
  SHORTDESCRIPTION
  STATUS
  USED
  USERAPPROVE
  USERCREATE
  VENDORRECOMMENDATIONS
}

"""Ordering options for Recommendations connections."""
input RecommendationsOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order Recommendations by."""
  field: RecommendationsOrderField
}

"""Properties by which Recommendations connections can be ordered."""
enum RecommendationsOrderField {
  """Order Recommendations by creation time."""
  CREATED_AT

  """Order Recommendations by name."""
  NAME

  """Order Recommendations by update time."""
  UPDATED_AT
}

type RecommendationsSources implements Node {
  id: ID!
  name: String!
  recommendations: [Recommendations!]
}

"""A connection to a list of RecommendationsSources."""
type RecommendationsSourcesConnection {
  """A list of RecommendationsSources edges."""
  edges: [RecommendationsSourcesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total RecommendationsSources of projects in all pages."""
  totalCount: Int!
}

"""A RecommendationsSources edge in a connection."""
type RecommendationsSourcesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The RecommendationsSources at the end of the edge."""
  node: RecommendationsSources
}

input RecommendationsSourcesFilterInput {
  filterType: RecommendationsSourcesFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum RecommendationsSourcesFilterType {
  NAME
}

"""Ordering options for RecommendationsSources connections."""
input RecommendationsSourcesOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order RecommendationsSources by."""
  field: RecommendationsSourcesOrderField
}

"""Properties by which RecommendationsSources connections can be ordered."""
enum RecommendationsSourcesOrderField {
  """Order RecommendationsSources by creation time."""
  CREATED_AT

  """Order RecommendationsSources by name."""
  NAME

  """Order RecommendationsSources by update time."""
  UPDATED_AT
}

input RegularHoursInput {
  timezone: String
  workdayEndHour: Int!
  workdayEndMinute: Int!
  workdayStartHour: Int!
  workdayStartMinute: Int!
}

type ReportFilter implements Node {
  entity: FilterEntity!
  filters: [GeneralFilter!]!
  id: ID!
  name: String!
}

input ReportFilterInput {
  entity: FilterEntity!
  filters: [GeneralFilterInput]
  name: String!
}

type Resource {
  available: Boolean
  belongs_to(filter: ResourceFilter): Resource
  composed_of(filter: Composed_ofFilter, first: Int, offset: Int): [Composed_of]
  composed_ofAggregate(filter: Composed_ofFilter): Composed_ofAggregateResult
  cross_connection(filter: ResourceFilter, first: Int, offset: Int, order: ResourceOrder): [Resource]
  cross_connectionAggregate(filter: ResourceFilter): ResourceAggregateResult
  externalId: Int
  id: ID!
  lifecycleStatus: LifecycleStatus
  logical_link(filter: ResourceFilter, first: Int, offset: Int, order: ResourceOrder): [Resource]
  logical_linkAggregate(filter: ResourceFilter): ResourceAggregateResult
  name: String!
  operationalSubStatus: OperationalSubStatus
  physical_link(filter: ResourceFilter): Resource
  planningSubStatus: PlanningSubStatus
  typePlanningSubStatus: TypePlanningSubStatus
  usageSubStatus: UsageSubStatus
}

type ResourceAggregateResult {
  count: Int
  externalIdAvg: Float
  externalIdMax: Int
  externalIdMin: Int
  externalIdSum: Int
  nameMax: String
  nameMin: String
}

input ResourceFilter {
  and: [ResourceFilter]
  has: [ResourceHasFilter]
  id: [ID!]
  name: StringHashFilter
  not: ResourceFilter
  or: [ResourceFilter]
}

enum ResourceHasFilter {
  available
  belongs_to
  composed_of
  cross_connection
  externalId
  lifecycleStatus
  logical_link
  name
  operationalSubStatus
  physical_link
  planningSubStatus
  typePlanningSubStatus
  usageSubStatus
}

input ResourceOrder {
  asc: ResourceOrderable
  desc: ResourceOrderable
  then: ResourceOrder
}

enum ResourceOrderable {
  externalId
  name
}

input ResourcePatch {
  available: Boolean
  belongs_to: ResourceRef
  composed_of: [Composed_ofRef]
  cross_connection: [ResourceRef]
  externalId: Int
  lifecycleStatus: LifecycleStatus
  logical_link: [ResourceRef]
  name: String
  operationalSubStatus: OperationalSubStatus
  physical_link: ResourceRef
  planningSubStatus: PlanningSubStatus
  typePlanningSubStatus: TypePlanningSubStatus
  usageSubStatus: UsageSubStatus
}

type ResourceProperty {
  booleanValue: Boolean
  floatValue: Float
  id: ID!
  intValue: Int
  latitudeValue: Float
  longitudeValue: Float
  rangeFromValue: Float
  rangeToValue: Float
  rawValue: String
  resource(filter: ResourceFilter, first: Int, offset: Int, order: ResourceOrder): [Resource]!
  resourceAggregate(filter: ResourceFilter): ResourceAggregateResult
  stringValue: String
}

type ResourcePropertyAggregateResult {
  count: Int
  floatValueAvg: Float
  floatValueMax: Float
  floatValueMin: Float
  floatValueSum: Float
  intValueAvg: Float
  intValueMax: Int
  intValueMin: Int
  intValueSum: Int
  latitudeValueAvg: Float
  latitudeValueMax: Float
  latitudeValueMin: Float
  latitudeValueSum: Float
  longitudeValueAvg: Float
  longitudeValueMax: Float
  longitudeValueMin: Float
  longitudeValueSum: Float
  rangeFromValueAvg: Float
  rangeFromValueMax: Float
  rangeFromValueMin: Float
  rangeFromValueSum: Float
  rangeToValueAvg: Float
  rangeToValueMax: Float
  rangeToValueMin: Float
  rangeToValueSum: Float
  rawValueMax: String
  rawValueMin: String
  stringValueMax: String
  stringValueMin: String
}

input ResourcePropertyFilter {
  and: [ResourcePropertyFilter]
  has: [ResourcePropertyHasFilter]
  id: [ID!]
  not: ResourcePropertyFilter
  or: [ResourcePropertyFilter]
}

enum ResourcePropertyHasFilter {
  booleanValue
  floatValue
  intValue
  latitudeValue
  longitudeValue
  rangeFromValue
  rangeToValue
  rawValue
  resource
  stringValue
}

enum ResourcePropertyKind {
  bool
  date
  datetime_local
  email
  enum
  float
  gps_location
  int
  node
  range
  string
}

input ResourcePropertyOrder {
  asc: ResourcePropertyOrderable
  desc: ResourcePropertyOrderable
  then: ResourcePropertyOrder
}

enum ResourcePropertyOrderable {
  floatValue
  intValue
  latitudeValue
  longitudeValue
  rangeFromValue
  rangeToValue
  rawValue
  stringValue
}

input ResourcePropertyPatch {
  booleanValue: Boolean
  floatValue: Float
  intValue: Int
  latitudeValue: Float
  longitudeValue: Float
  rangeFromValue: Float
  rangeToValue: Float
  rawValue: String
  resource: [ResourceRef]
  stringValue: String
}

input ResourcePropertyRef {
  booleanValue: Boolean
  floatValue: Float
  id: ID
  intValue: Int
  latitudeValue: Float
  longitudeValue: Float
  rangeFromValue: Float
  rangeToValue: Float
  rawValue: String
  resource: [ResourceRef]
  stringValue: String
}

type ResourcePropertyType implements Node {
  booleanValue: Boolean
  category: String
  externalId: String
  floatValue: Float
  id: ID!
  index: Int
  intValue: Int
  isDeleted: Boolean
  isEditable: Boolean
  isInstanceProperty: Boolean
  isListable: Boolean
  isMandatory: Boolean
  latitudeValue: Float
  longitudeValue: Float
  name: String!
  nodeType: String
  propertyCategory: PropertyCategory
  rangeFromValue: Float
  rangeToValue: Float
  rawValue: String
  resourceSpecification: ResourceSpecification!
  stringValue: String
  type: ResourcePropertyKind!
}

input ResourceRef {
  available: Boolean
  belongs_to: ResourceRef
  composed_of: [Composed_ofRef]
  cross_connection: [ResourceRef]
  externalId: Int
  id: ID
  lifecycleStatus: LifecycleStatus
  logical_link: [ResourceRef]
  name: String
  operationalSubStatus: OperationalSubStatus
  physical_link: ResourceRef
  planningSubStatus: PlanningSubStatus
  typePlanningSubStatus: TypePlanningSubStatus
  usageSubStatus: UsageSubStatus
}

enum ResourceRelationshipMultiplicityKind {
  MANY_TO_MANY
  MANY_TO_ONE
  ONE_TO_MANY
  ONE_TO_ONE
}

enum ResourceRelationshipTypeKind {
  BELONGS_TO
  CROSS_CONNECTION
  LOCATED_IN
  LOGICAL_LINK
  PHYSICAL_LINK
}

type ResourceSpecification implements Node {
  id: ID!
  name: String!
  quantity: Int
  resourcePropertyTypes: [ResourcePropertyType]!
  resourceSpecificationItems: [ResourceSpecificationItems]
  resourceSpecificationRelationship: [ResourceSpecificationRelationship]
  resourceType: ResourceType
  vendor: Vendor
}

"""A connection to a list of ResourceSpecification."""
type ResourceSpecificationConnection {
  """A list of ResourceSpecification edges."""
  edges: [ResourceSpecificationEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total ResourceSpecification of projects in all pages."""
  totalCount: Int!
}

"""A ResourceSpecification edge in a connection."""
type ResourceSpecificationEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The ResourceSpecification at the end of the edge."""
  node: ResourceSpecification
}

input ResourceSpecificationFilterInput {
  filterType: ResourceSpecificationFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum ResourceSpecificationFilterType {
  ID
  NAME
  RESOURCE_TYPE
}

type ResourceSpecificationItems implements Node {
  id: ID!
  resourceSpecification: ResourceSpecification
  resourceSpecificationRelationship: ResourceSpecificationRelationship!
}

"""A connection to a list of ResourceSpecificationItems."""
type ResourceSpecificationItemsConnection {
  """A list of ResourceSpecificationItems edges."""
  edges: [ResourceSpecificationItemsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total ResourceSpecificationItems of projects in all pages."""
  totalCount: Int!
}

"""A ResourceSpecificationItems edge in a connection."""
type ResourceSpecificationItemsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The ResourceSpecificationItems at the end of the edge."""
  node: ResourceSpecificationItems
}

input ResourceSpecificationItemsFilterInput {
  filterType: ResourceSpecificationItemsFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
}

enum ResourceSpecificationItemsFilterType {
  RESOURCE_SPECIFICATION
  RESOURCE_SPECIFICATION_RELATIONSHIP
}

"""Ordering options for ResourceSpecification connections."""
input ResourceSpecificationOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order ResourceSpecification by."""
  field: ResourceSpecificationOrderField
}

"""Properties by which ResourceSpecification connections can be ordered."""
enum ResourceSpecificationOrderField {
  """Order ResourceSpecification by creation time."""
  CREATED_AT

  """Order ResourceSpecification by name."""
  NAME

  """Order ResourceType by name."""
  RESOURCE_TYPE

  """Order ResourceSpecification by update time."""
  UPDATED_AT
}

type ResourceSpecificationRelationship implements Node {
  id: ID!
  name: String!
  resourceSpecification: ResourceSpecification!
  resourceSpecificationItems: [ResourceSpecificationItems]
}

"""A connection to a list of ResourceSpecificationRelationships."""
type ResourceSpecificationRelationshipConnection {
  """A list of ResourceSpecificationRelationships edges."""
  edges: [ResourceSpecificationRelationshipEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total ResourceSpecificationRelationships of projects in all pages."""
  totalCount: Int!
}

"""A ResourceSpecificationRelationships edge in a connection."""
type ResourceSpecificationRelationshipEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The ResourceSpecificationRelationships at the end of the edge."""
  node: ResourceSpecificationRelationship
}

input ResourceSpecificationRelationshipFilterInput {
  filterType: ResourceSpecificationRelationshipFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum ResourceSpecificationRelationshipFilterType {
  NAME
  RESOURCE_SPECIFICATION
}

"""Ordering options for ResourceSpecificationRelationships connections."""
input ResourceSpecificationRelationshipOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order ResourceSpecificationRelationships by."""
  field: ResourceSpecificationRelationshipOrderField
}

"""
Properties by which ResourceSpecificationRelationships connections can be ordered.
"""
enum ResourceSpecificationRelationshipOrderField {
  """Order ResourceSpecificationRelationships by creation time."""
  CREATED_AT

  """Order ResourceSpecificationRelationships by name."""
  NAME

  """Order ResourceSpecificationRelationships by update time."""
  UPDATED_AT
}

type ResourceType implements Node {
  id: ID!
  name: String!
  resourceSpecification: [ResourceSpecification]
  resourceTypeBaseType: ResourceTypeBaseTypeKind!
  resourceTypeClass: ResourceTypeClassKind!
}

enum ResourceTypeBaseTypeKind {
  LOGICAL_RESOURCE
  PHYSICAL_RESOURCE
  VIRTUAL_RESOURCE
}

enum ResourceTypeClassKind {
  CARD
  EQUIPMENT
  NETWORK_FUNCTION
  PORT
  RACK
  SLOT
  VLAN
}

"""A connection to a list of ResourceType."""
type ResourceTypeConnection {
  """A list of ResourceType edges."""
  edges: [ResourceTypeEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total ResourceType of projects in all pages."""
  totalCount: Int!
}

"""A ResourceType edge in a connection."""
type ResourceTypeEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The ResourceType at the end of the edge."""
  node: ResourceType
}

input ResourceTypeFilterInput {
  filterType: ResourceTypeFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
  typeBaseTypeValue: ResourceTypeBaseTypeKind
  typeClassValue: ResourceTypeClassKind
}

enum ResourceTypeFilterType {
  NAME
  RESOURCE_TYPE_BASE_TYPE
  RESOURCE_TYPE_CLASS
}

"""Ordering options for ResourceType connections."""
input ResourceTypeOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order ResourceType by."""
  field: ResourceTypeOrderField
}

"""Properties by which ResourceType connections can be ordered."""
enum ResourceTypeOrderField {
  """Order ResourceType by creation time."""
  CREATED_AT

  """Order ResourceType by name."""
  NAME

  """Order ResourceType by BaseType."""
  RESOURCE_TYPE_BASE_TYPE

  """Order ResourceType by TypeClass."""
  RESOURCE_TYPE_CLASS

  """Order ResourceType by update time."""
  UPDATED_AT
}

type ResourceTypeRelationship implements Node {
  id: ID!
  locationType: LocationType
  resourceRelationshipMultiplicity: ResourceRelationshipMultiplicityKind!
  resourceRelationshipType: ResourceRelationshipTypeKind!
  resourceTypeA: ResourceType!
  resourceTypeB: ResourceType
}

"""A connection to a list of ResourceTypeRelationship."""
type ResourceTypeRelationshipConnection {
  """A list of ResourceTypeRelationship edges."""
  edges: [ResourceTypeRelationshipEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total ResourceTypeRelationship of projects in all pages."""
  totalCount: Int!
}

"""A ResourceTypeRelationship edge in a connection."""
type ResourceTypeRelationshipEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The ResourceTypeRelationship at the end of the edge."""
  node: ResourceTypeRelationship
}

input ResourceTypeRelationshipFilterInput {
  filterType: ResourceTypeRelationshipFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  multiplicityValue: ResourceRelationshipMultiplicityKind
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
  typeValue: ResourceRelationshipTypeKind
}

enum ResourceTypeRelationshipFilterType {
  RESOURCE_RELATIONSHIP_LOCATION_TYPE
  RESOURCE_RELATIONSHIP_MULTIPLICITY
  RESOURCE_RELATIONSHIP_RESOURCE
  RESOURCE_RELATIONSHIP_TYPE
  RESOURCE_RELATIONSHIP_TYPE_A
  RESOURCE_RELATIONSHIP_TYPE_B
}

"""Ordering options for ResourceTypeRelationship connections."""
input ResourceTypeRelationshipOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order ResourceTypeRelationship by."""
  field: ResourceTypeRelationshipOrderField
}

"""
Properties by which ResourceTypeRelationship connections can be ordered.
"""
enum ResourceTypeRelationshipOrderField {
  """Order ResourceTypeRelationship by creation time."""
  CREATED_AT

  """Order ResourceTypeRelationship by LocationType."""
  LOCATION_TYPE

  """Order ResourceTypeRelationship by ResourceRelationshipMultiplicity."""
  RESOURCE_RELATIONSHIP_MULTIPLICITY

  """Order ResourceTypeRelationship by ResourceRelationshipType."""
  RESOURCE_RELATIONSHIP_TYPE

  """Order ResourceTypeRelationship by ResourceTypeA."""
  RESOURCE_TYPE_A

  """Order ResourceTypeRelationship by ResourceTypeB."""
  RESOURCE_TYPE_B

  """Order ResourceTypeRelationship by update time."""
  UPDATED_AT
}

enum RetryUnit {
  HOURS
  MINUTES
  SECONDS
}

enum RollbackPolicyConfig {
  APPROVED
  REJECTED
}

type Rule implements Node {
  additionalInfo: String
  endDateTime: Time
  eventSeverity: EventSeverity!
  eventTypeName: String
  gracePeriod: Int
  id: ID!
  name: String!
  ruleLimit: [RuleLimit!]
  ruleType: RuleType!
  specificProblem: String
  startDateTime: Time
  status: Boolean!
  threshold: Threshold!
}

input RuleInput {
  additionalInfo: String!
  endDateTime: Time
  eventTypeName: String!
  gracePeriod: Int
  name: String!
  ruleLimit: [RuleLimitInput!]
  specificProblem: String!
  startDateTime: Time
  status: Boolean!
}

type RuleLimit implements Node {
  comparator: Comparator!
  id: ID!
  limitType: String!
  number: Int!
  rule: Rule
}

input RuleLimitInput {
  comparator: ID!
  limitType: String!
  number: Int!
  rule: ID!
}

type RuleType implements Node {
  id: ID!
  name: String!
  rule: [Rule!]
}

"""A connection to a list of ruleTypes."""
type RuleTypeConnection {
  """A list of ruleTypes edges."""
  edges: [RuleTypeEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total ruleTypes of projects in all pages."""
  totalCount: Int!
}

"""A ruleTypes edge in a connection."""
type RuleTypeEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The ruleTypes at the end of the edge."""
  node: RuleType
}

input RuleTypeFilterInput {
  filterType: RuleTypeFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum RuleTypeFilterType {
  NAME
}

"""Ordering options for ruleTypes connections."""
input RuleTypeOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order ruleTypes by."""
  field: RuleTypeOrderField
}

"""Properties by which ruleTypes connections can be ordered."""
enum RuleTypeOrderField {
  """Order ruleTypes by creation time."""
  CREATED_AT

  """Order ruleTypes by name."""
  NAME

  """Order ruleTypes by update time."""
  UPDATED_AT
}

type SchedulerConfig {
  changeRequest(filter: ChangeRequestFilter): ChangeRequest!
  createTime: DateTime!
  id: ID!
  name: String
  rollbackPolicy: RollbackPolicyConfig
  status: SchedulerConfigStatus!
  time: DateTime
  weekDay: WeekDay!
}

type SchedulerConfigAggregateResult {
  count: Int
  createTimeMax: DateTime
  createTimeMin: DateTime
  nameMax: String
  nameMin: String
  timeMax: DateTime
  timeMin: DateTime
}

input SchedulerConfigFilter {
  and: [SchedulerConfigFilter]
  has: [SchedulerConfigHasFilter]
  id: [ID!]
  not: SchedulerConfigFilter
  or: [SchedulerConfigFilter]
}

enum SchedulerConfigHasFilter {
  changeRequest
  createTime
  name
  rollbackPolicy
  status
  time
  weekDay
}

input SchedulerConfigOrder {
  asc: SchedulerConfigOrderable
  desc: SchedulerConfigOrderable
  then: SchedulerConfigOrder
}

enum SchedulerConfigOrderable {
  createTime
  name
  time
}

input SchedulerConfigPatch {
  changeRequest: ChangeRequestRef
  createTime: DateTime
  name: String
  rollbackPolicy: RollbackPolicyConfig
  status: SchedulerConfigStatus
  time: DateTime
  weekDay: WeekDay
}

input SchedulerConfigRef {
  changeRequest: ChangeRequestRef
  createTime: DateTime
  id: ID
  name: String
  rollbackPolicy: RollbackPolicyConfig
  status: SchedulerConfigStatus
  time: DateTime
  weekDay: WeekDay
}

enum SchedulerConfigStatus {
  APPROVED
  REJECTED
}

type SearchEntry {
  entityId: ID!
  entityType: String!
  externalId: String
  name: String!
  type: String!
}

"""A search node edge in a connection."""
type SearchNodeEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The search node at the end of the edge."""
  node: Node
}

"""A connection to a list of search nodes."""
type SearchNodesConnection {
  """A list of search node edges."""
  edges: [SearchNodeEdge!]

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of search nodes in all pages."""
  totalCount: Int!
}

"""Modeling a specific service: e.g. a L2 VPN instance."""
type Service implements NamedNode & Node {
  customer: Customer
  downstream: [Service]!
  endpoints: [ServiceEndpoint]!
  externalId: String
  id: ID!
  links: [Link]!
  name: String!
  ports: [EquipmentPort]!
  properties: [Property]!
  serviceType: ServiceType!
  status: ServiceStatus!
  topology: NetworkTopology!
  upstream: [Service]!
}

"""A connection to a list of services."""
type ServiceConnection {
  """A list of service edges."""
  edges: [ServiceEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of services in all pages."""
  totalCount: Int!
}

input ServiceCreateData {
  customerId: ID
  externalId: String
  name: String!
  properties: [PropertyInput]
  serviceTypeId: ID!
  status: ServiceStatus! = PENDING
  upstreamServiceIds: [ID!]!
}

"""A service edge in a connection."""
type ServiceEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The service at the end of the edge."""
  node: Service
}

input ServiceEditData {
  customerId: ID
  externalId: String
  id: ID!
  name: String
  properties: [PropertyInput]
  status: ServiceStatus
  upstreamServiceIds: [ID!]
}

type ServiceEndpoint implements Node {
  definition: ServiceEndpointDefinition!
  equipment: Equipment!
  id: ID!
  port: EquipmentPort
  service: Service!
}

type ServiceEndpointDefinition implements Node {
  endpoints: [ServiceEndpoint]!
  equipmentType: EquipmentType!
  id: ID!
  index: Int!
  name: String!
  role: String
  serviceType: ServiceType!
}

input ServiceEndpointDefinitionInput {
  equipmentTypeID: ID!
  id: ID
  index: Int!
  name: String!
  role: String
}

input ServiceFilterInput {
  filterType: ServiceFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  propertyValue: PropertyTypeInput
  stringSet: [String!]
  stringValue: String
}

"""what filters should we apply on services"""
enum ServiceFilterType {
  EQUIPMENT_IN_SERVICE
  LOCATION_INST
  LOCATION_INST_EXTERNAL_ID
  PROPERTY
  SERVICE_DISCOVERY_METHOD
  SERVICE_INST_CUSTOMER_NAME
  SERVICE_INST_EXTERNAL_ID
  SERVICE_INST_NAME
  SERVICE_STATUS
  SERVICE_TYPE
}

type ServiceSearchResult {
  count: Int!
  services: [Service]!
}

enum ServiceStatus {
  DISCONNECTED
  IN_SERVICE
  MAINTENANCE
  PENDING
}

"""Service type schema: e.g. L2 VPN."""
type ServiceType implements Node {
  discoveryMethod: DiscoveryMethod!
  endpointDefinitions: [ServiceEndpointDefinition!]!
  hasCustomer: Boolean!
  id: ID!
  isDeleted: Boolean!
  name: String!
  numberOfServices: Int!
  propertyTypes: [PropertyType]!
  services: [Service]!
}

"""A connection to a list of service types."""
type ServiceTypeConnection {
  """A list of service type edges."""
  edges: [ServiceTypeEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of service types in all pages."""
  totalCount: Int!
}

input ServiceTypeCreateData {
  discoveryMethod: DiscoveryMethod
  endpoints: [ServiceEndpointDefinitionInput]
  hasCustomer: Boolean!
  name: String!
  properties: [PropertyTypeInput]
}

"""A service type edge in a connection."""
type ServiceTypeEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The service type at the end of the edge."""
  node: ServiceType
}

input ServiceTypeEditData {
  endpoints: [ServiceEndpointDefinitionInput]
  hasCustomer: Boolean!
  id: ID!
  name: String!
  properties: [PropertyTypeInput]
}

enum SignalModule {
  ASSURANCE
  CM
  INVENTORY
  WFM
}

enum SignalType {
  CRCREATED
  CRUPDATED
  MOICREATED
  MOIUPDATED
  PR_CREATED
  PR_UPDATED
  WOCREATED
  WOUPDATED
}

input SlotFilterInput {
  slotEndDate: Time!
  slotStartDate: Time!
}

type StartBlock {
  exitPoint: ExitPoint!
  paramDefinitions: [VariableDefinition!]!
}

input StartBlockInput {
  cid: String!
  paramDefinitions: [VariableDefinitionInput!]
  uiRepresentation: BlockUIRepresentationInput
}

input StartFlowInput {
  bssCode: String
  flowID: ID!
  params: [VariableValueInput]!
  startDate: Time!
}

input StringExactFilter {
  between: StringRange
  eq: String
  ge: String
  gt: String
  in: [String]
  le: String
  lt: String
}

input StringFullTextFilter {
  alloftext: String
  anyoftext: String
}

input StringHashFilter {
  eq: String
  in: [String]
}

input StringRange {
  max: String!
  min: String!
}

input StringRegExpFilter {
  regexp: String
}

input StringTermFilter {
  allofterms: String
  anyofterms: String
}

type SubflowBlock {
  entryPoint: EntryPoint!
  exitPoint: ExitPoint!
  flow: Flow
  params: [VariableExpression!]!
}

input SubflowBlockInput {
  cid: String!
  flowId: ID!
  params: [VariableExpressionInput!]!
  uiRepresentation: BlockUIRepresentationInput
}

type Survey implements Node {
  completionTimestamp: Int!
  creationTimestamp: Int
  id: ID!
  locationID: ID!
  name: String!
  ownerName: String
  sourceFile: File
  surveyResponses: [SurveyQuestion]!
}

type SurveyCellScan implements Node {
  altitude: Float
  arfcn: Int
  baseStationID: String
  cellID: String
  earfcn: Int
  heading: Float
  id: ID!
  latitude: Float
  locationAreaCode: String
  longitude: Float
  mobileCountryCode: String
  mobileNetworkCode: String
  networkID: String
  networkType: CellularNetworkType!
  operator: String
  physicalCellID: String
  primaryScramblingCode: String
  rssi: Float
  signalStrength: Int!
  systemID: String
  timestamp: Int
  timingAdvance: Int
  trackingAreaCode: String
  uarfcn: Int
}

input SurveyCellScanData {
  altitude: Float
  arfcn: Int
  baseStationID: String
  cellID: String
  earfcn: Int
  heading: Float
  latitude: Float
  locationAreaCode: String
  longitude: Float
  mobileCountryCode: String
  mobileNetworkCode: String
  networkID: String
  networkType: CellularNetworkType!
  operator: String
  physicalCellID: String
  primaryScramblingCode: String
  rssi: Float
  signalStrength: Int!
  systemID: String
  timestamp: Int
  timingAdvance: Int
  trackingAreaCode: String
  uarfcn: Int
}

input SurveyCreateData {
  completionTimestamp: Int!
  creationTimestamp: Int
  locationID: ID!
  name: String!
  ownerName: String
  status: SurveyStatus
  surveyResponses: [SurveyQuestionResponse!]!
}

type SurveyQuestion implements Node {
  altitude: Float
  boolData: Boolean
  cellData: [SurveyCellScan]
  dateData: Int
  emailData: String
  floatData: Float
  formDescription: String
  formIndex: Int!
  formName: String
  id: ID!
  images: [File!]
  intData: Int
  latitude: Float
  locationAccuracy: Float
  longitude: Float
  phoneData: String
  photoData: File
  questionFormat: SurveyQuestionType
  questionIndex: Int!
  questionText: String!
  textData: String
  wifiData: [SurveyWiFiScan]
}

input SurveyQuestionResponse {
  altitude: Float
  boolData: Boolean
  cellData: [SurveyCellScanData!]
  dateData: Int
  emailData: String
  floatData: Float
  formDescription: String
  formIndex: Int!
  formName: String
  imagesData: [FileInput!]
  intData: Int
  latitude: Float
  locationAccuracy: Float
  longitude: Float
  phoneData: String
  photoData: FileInput
  questionFormat: SurveyQuestionType
  questionIndex: Int!
  questionText: String!
  textData: String
  wifiData: [SurveyWiFiScanData!]
}

enum SurveyQuestionType {
  BOOL
  CELLULAR
  COORDS
  DATE
  EMAIL
  FLOAT
  INTEGER
  PHONE
  PHOTO
  TEXT
  TEXTAREA
  WIFI
}

enum SurveyStatus {
  COMPLETED
  INPROGRESS
  PLANNED
}

type SurveyTemplateCategory implements Node {
  categoryDescription: String!
  categoryTitle: String!
  id: ID!
  surveyTemplateQuestions: [SurveyTemplateQuestion]
}

input SurveyTemplateCategoryInput {
  categoryDescription: String!
  categoryTitle: String!
  id: ID
  surveyTemplateQuestions: [SurveyTemplateQuestionInput]
}

type SurveyTemplateQuestion implements Node {
  id: ID!
  index: Int!
  questionDescription: String!
  questionTitle: String!
  questionType: SurveyQuestionType!
}

input SurveyTemplateQuestionInput {
  id: ID
  index: Int!
  questionDescription: String!
  questionTitle: String!
  questionType: SurveyQuestionType!
}

type SurveyWiFiScan implements Node {
  altitude: Float
  band: String
  bssid: String!
  capabilities: String
  channel: Int!
  channelWidth: Int
  frequency: Int!
  heading: Float
  id: ID!
  latitude: Float
  longitude: Float
  rssi: Float
  ssid: String
  strength: Int!
  timestamp: Int!
}

input SurveyWiFiScanData {
  altitude: Float
  band: String
  bssid: String!
  capabilities: String
  channel: Int!
  channelWidth: Int
  frequency: Int!
  heading: Float
  latitude: Float
  longitude: Float
  rssi: Float
  ssid: String
  strength: Int!
  timestamp: Int!
}

union SystemPolicy = AssurancePolicy | AutomationPolicy | InventoryPolicy | WorkforcePolicy

type Tech implements Node {
  domainFk: Domain!
  id: ID!
  name: String!
}

"""A connection to a list of techs."""
type TechConnection {
  """A list of techs edges."""
  edges: [TechEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total techs of projects in all pages."""
  totalCount: Int!
}

"""A techs edge in a connection."""
type TechEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The techs at the end of the edge."""
  node: Tech
}

input TechFilterInput {
  filterType: TechFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum TechFilterType {
  NAME
}

"""Ordering options for techs connections."""
input TechOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order techs by."""
  field: TechOrderField
}

"""Properties by which techs connections can be ordered."""
enum TechOrderField {
  """Order techs by creation time."""
  CREATED_AT

  """Order techs by name."""
  NAME

  """Order techs by update time."""
  UPDATED_AT
}

input TechnicianCheckListItemInput {
  cellData: [SurveyCellScanData!]
  checked: Boolean
  filesData: [FileInput!]
  id: ID!
  selectedEnumValues: String
  stringValue: String
  wifiData: [SurveyWiFiScanData!]
  yesNoResponse: YesNoResponse
}

input TechnicianWorkOrderCheckInInput {
  checkInTime: Time
  distanceMeters: Float
}

input TechnicianWorkOrderCheckOutInput {
  checkListCategories: [CheckListCategoryInput!]
  checkOutTime: Time
  comment: String
  distanceMeters: Float
  reason: ClockOutReason!
  workOrderId: ID!
}

input TechnicianWorkOrderUploadInput {
  checkListCategories: [CheckListCategoryInput!]
  workOrderId: ID!
}

type Threshold implements Node {
  description: String!
  id: ID!
  kpi: Kpi
  name: String!
  rule: [Rule!]
  status: Boolean!
}

"""A connection to a list of Threshold."""
type ThresholdConnection {
  """A list of Threshold edges."""
  edges: [ThresholdEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total Threshold of projects in all pages."""
  totalCount: Int!
}

"""A Threshold edge in a connection."""
type ThresholdEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The Threshold at the end of the edge."""
  node: Threshold
}

input ThresholdFilterInput {
  filterType: ThresholdFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum ThresholdFilterType {
  NAME
}

input ThresholdInput {
  description: String!
  kpi: ID!
  name: String!
  rule: [RuleInput!]
  status: Boolean!
}

"""Ordering options for Threshold connections."""
input ThresholdOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order Threshold by."""
  field: ThresholdOrderField
}

"""Properties by which Threshold connections can be ordered."""
enum ThresholdOrderField {
  """Order Threshold by creation time."""
  CREATED_AT

  """Order Threshold by name."""
  NAME

  """Order Threshold by update time."""
  UPDATED_AT
}

scalar Time

enum TimerBehavior {
  FIXED_INTERVAL
  SPECIFIC_DATETIME
}

type TimerBlock {
  behavior: TimerBehavior!
  datetime: Time
  enableExpressionL: Boolean
  exitPoint: ExitPoint!
  expression: String
  seconds: Int
}

input TimerBlockInput {
  behavior: TimerBehavior!
  cid: String!
  enableExpressionL: Boolean
  entryPoint: EntryPointInput
  exitPoint: ExitPointInput
  expression: String
  params: [VariableExpressionInput!]
  seconds: Int
  specificDatetime: Time
  uiRepresentation: BlockUIRepresentationInput
}

type TopologyLink {
  source: Node!
  target: Node!
  type: TopologyLinkType!
}

enum TopologyLinkType {
  PHYSICAL
}

enum TransfStrategy {
  MERGE
  REPLACE
}

type TriggerBlock {
  exitPoint: ExitPoint!
  params: [VariableExpression!]!
  triggerType: TriggerType!
}

input TriggerBlockInput {
  cid: String!
  params: [VariableExpressionInput!]!
  triggerType: TriggerTypeId!
  uiRepresentation: BlockUIRepresentationInput
}

type TriggerType {
  description: String!
  id: TriggerTypeId!
  variables: [VariableDefinition!]!
}

enum TriggerTypeId {
  work_order
}

type TrueFalseBlock {
  entryPoint: EntryPoint!
  falseExitPoint: ExitPoint!
  trueExitPoint: ExitPoint!
}

input TrueFalseBlockInput {
  cid: String!
  uiRepresentation: BlockUIRepresentationInput
}

enum TypePlanningSubStatus {
  DESIGNED
  FEASIBILITY_CHECKED
  ORDERED
  PROPOSED
}

input UpdateCMVersionInput {
  filter: CMVersionFilter!
  remove: CMVersionPatch
  set: CMVersionPatch
}

type UpdateCMVersionPayload {
  cMVersion(filter: CMVersionFilter, first: Int, offset: Int, order: CMVersionOrder): [CMVersion]
  numUids: Int
}

input UpdateChangeItemInput {
  filter: ChangeItemFilter!
  remove: ChangeItemPatch
  set: ChangeItemPatch
}

type UpdateChangeItemPayload {
  changeItem(filter: ChangeItemFilter, first: Int, offset: Int, order: ChangeItemOrder): [ChangeItem]
  numUids: Int
}

input UpdateChangeRequestActivityInput {
  filter: ChangeRequestActivityFilter!
  remove: ChangeRequestActivityPatch
  set: ChangeRequestActivityPatch
}

type UpdateChangeRequestActivityPayload {
  changeRequestActivity(filter: ChangeRequestActivityFilter, first: Int, offset: Int, order: ChangeRequestActivityOrder): [ChangeRequestActivity]
  numUids: Int
}

input UpdateChangeRequestInput {
  filter: ChangeRequestFilter!
  remove: ChangeRequestPatch
  set: ChangeRequestPatch
}

type UpdateChangeRequestPayload {
  changeRequest(filter: ChangeRequestFilter, first: Int, offset: Int, order: ChangeRequestOrder): [ChangeRequest]
  numUids: Int
}

input UpdateComposed_ofInput {
  filter: Composed_ofFilter!
  remove: Composed_ofPatch
  set: Composed_ofPatch
}

type UpdateComposed_ofPayload {
  composed_of(filter: Composed_ofFilter, first: Int, offset: Int): [Composed_of]
  numUids: Int
}

input UpdateConfigParamTagInput {
  filter: ConfigParamTagFilter!
  remove: ConfigParamTagPatch
  set: ConfigParamTagPatch
}

type UpdateConfigParamTagPayload {
  configParamTag(filter: ConfigParamTagFilter, first: Int, offset: Int, order: ConfigParamTagOrder): [ConfigParamTag]
  numUids: Int
}

input UpdateConfigurationParameterTypeInput {
  filter: ConfigurationParameterTypeFilter!
  remove: ConfigurationParameterTypePatch
  set: ConfigurationParameterTypePatch
}

type UpdateConfigurationParameterTypePayload {
  configurationParameterType(filter: ConfigurationParameterTypeFilter, first: Int, offset: Int, order: ConfigurationParameterTypeOrder): [ConfigurationParameterType]
  numUids: Int
}

input UpdateParameterInput {
  filter: ParameterFilter!
  remove: ParameterPatch
  set: ParameterPatch
}

type UpdateParameterPayload {
  numUids: Int
  parameter(filter: ParameterFilter, first: Int, offset: Int, order: ParameterOrder): [Parameter]
}

input UpdateResourceInput {
  filter: ResourceFilter!
  remove: ResourcePatch
  set: ResourcePatch
}

type UpdateResourcePayload {
  numUids: Int
  resource(filter: ResourceFilter, first: Int, offset: Int, order: ResourceOrder): [Resource]
}

input UpdateResourcePropertyInput {
  filter: ResourcePropertyFilter!
  remove: ResourcePropertyPatch
  set: ResourcePropertyPatch
}

type UpdateResourcePropertyPayload {
  numUids: Int
  resourceProperty(filter: ResourcePropertyFilter, first: Int, offset: Int, order: ResourcePropertyOrder): [ResourceProperty]
}

input UpdateSchedulerConfigInput {
  filter: SchedulerConfigFilter!
  remove: SchedulerConfigPatch
  set: SchedulerConfigPatch
}

type UpdateSchedulerConfigPayload {
  numUids: Int
  schedulerConfig(filter: SchedulerConfigFilter, first: Int, offset: Int, order: SchedulerConfigOrder): [SchedulerConfig]
}

input UpdateUserGroupsInput {
  addGroupIds: [ID!]!
  id: ID!
  removeGroupIds: [ID!]!
}

enum UrlMethod {
  DELETE
  GET
  PATCH
  POST
  PUT
}

enum UsageSubStatus {
  ASSIGNED
  AVAILABLE
  NO_AVAILABLE
  RESERVED
}

type User implements NamedNode & Node {
  authID: String!
  distanceUnit: DistanceUnit
  email: String!
  firstName: String!
  groups: [UsersGroup]!
  id: ID!
  lastName: String!
  name: String!
  organizationFk: Organization
  profilePhoto: File
  role: UserRole!
  status: UserStatus!
}

type UserAvailability {
  slotEndDate: Time!
  slotStartDate: Time!
  user: User!
}

"""A connection to a list of users."""
type UserConnection {
  """A list of user type edges."""
  edges: [UserEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of users in all pages."""
  totalCount: Int!
}

"""A work order type edge in a connection."""
type UserEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The user type at the end of the edge."""
  node: User
}

input UserFilterInput {
  filterType: UserFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  propertyValue: PropertyTypeInput
  statusValue: UserStatus
  stringSet: [String!]
  stringValue: String
}

"""what filters should we apply on users"""
enum UserFilterType {
  USER_NAME
  USER_ORGANIZATION
  USER_STATUS
}

enum UserRole {
  ADMIN
  OWNER
  USER
}

type UserSearchResult {
  count: Int!
  users: [User]!
}

enum UserStatus {
  ACTIVE
  DEACTIVATED
}

type UsersGroup implements Node {
  description: String
  id: ID!
  members: [User!]!
  name: String!
  policies: [PermissionsPolicy!]!
  status: UsersGroupStatus!
}

"""A connection to a list of users groups."""
type UsersGroupConnection {
  """A list of users group type edges."""
  edges: [UsersGroupEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of user groups in all pages."""
  totalCount: Int!
}

"""A work order type edge in a connection."""
type UsersGroupEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The user type at the end of the edge."""
  node: UsersGroup
}

input UsersGroupFilterInput {
  filterType: UsersGroupFilterType!
  maxDepth: Int = 5
  operator: FilterOperator!
  stringValue: String
}

"""what filters should we apply on usersGroups"""
enum UsersGroupFilterType {
  GROUP_NAME
}

type UsersGroupSearchResult {
  count: Int!
  usersGroups: [UsersGroup]!
}

enum UsersGroupStatus {
  ACTIVE
  DEACTIVATED
}

type VariableDefinition {
  choices: [String!]
  defaultValue: String
  key: String!
  mandatory: Boolean!
  multipleValues: Boolean!
  name: String!
  nestedVariables(value: String!): [VariableDefinition!]!
  type: VariableType!
  usage: VariableUsage!
}

input VariableDefinitionInput {
  choices: [String!]
  defaultValue: String
  key: String!
  mandatory: Boolean
  multipleValues: Boolean
  type: VariableType!
}

type VariableExpression {
  blockVariables: [BlockVariable!]
  expression: String!
  propertyTypeDefinition: PropertyType
  type: VariableExpressionType!
  variableDefinition: VariableDefinition
}

input VariableExpressionInput {
  blockVariables: [BlockVariableInput!]
  expression: String!
  propertyTypeId: Int
  type: VariableExpressionType!
  variableDefinitionKey: String
}

"""what type variableExpression should we apply"""
enum VariableExpressionType {
  ChekListItemDefinition
  DecisionDefinition
  PropertyTypeDefinition
  VariableDefinition
}

enum VariableType {
  DATE
  INT
  LOCATION
  PROJECT
  STRING
  USER
  WORK_ORDER
  WORK_ORDER_TYPE
}

enum VariableUsage {
  INPUT
  INPUT_AND_OUTPUT
  OUTPUT
}

type VariableValue {
  value: String!
  variableDefinitionKey: String!
}

input VariableValueInput {
  value: String!
  variableDefinitionKey: String!
}

type Vendor implements Node {
  id: ID!
  name: String!
  resourceSpecification: [ResourceSpecification!]
  vendorRecommendations: [Recommendations!]
}

"""A connection to a list of vendors."""
type VendorConnection {
  """A list of vendors edges."""
  edges: [VendorEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total vendors of projects in all pages."""
  totalCount: Int!
}

"""A vendors edge in a connection."""
type VendorEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The vendors at the end of the edge."""
  node: Vendor
}

input VendorFilterInput {
  filterType: VendorFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  stringSet: [String!]
  stringValue: String
}

enum VendorFilterType {
  NAME
}

"""Ordering options for vendors connections."""
input VendorOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order vendors by."""
  field: VendorOrderField
}

"""Properties by which vendors connections can be ordered."""
enum VendorOrderField {
  """Order vendors by creation time."""
  CREATED_AT

  """Order vendors by name."""
  NAME

  """Order vendors by update time."""
  UPDATED_AT
}

enum VersionStatus {
  CURRENT
  REPLACED
}

type Vertex {
  edges: [Edge!]!
  fields: [Field!]!
  id: ID!
  type: String!
}

type Viewer {
  permissions: PermissionSettings!
  tenant: String!
  user: User
}

type WaitForSignalBlock {
  blocked: Boolean!
  customFilter: String
  entryPoint: EntryPoint!
  exitPoint: ExitPoint!
  signalModule: SignalModule
  type: SignalType
}

input WaitForSignalBlockInput {
  basicDefinitions: BaseBlockInput!
  blocked: Boolean!
  cid: String!
  customFilter: String
  entryPoint: EntryPointInput
  exitPoint: ExitPointInput
  params: [VariableExpressionInput!]
  signalModule: SignalModule!
  type: SignalType!
  uiRepresentation: BlockUIRepresentationInput
}

enum WeekDay {
  FRIDAY
  MONDAY
  SATURDAY
  SUNDAY
  THURSDAY
  TUESDAY
  WEDNESDAY
}

input WithinFilter {
  polygon: PolygonRef!
}

"""
Work Order instance - capturing information about a change in the network
"""
type WorkOrder implements NamedNode & Node {
  Appointments: [Appointment]
  activities(filter: ActivityFilterInput): [Activity!]!
  assignedTo: User
  checkListCategories: [CheckListCategory!]!
  closeDate: Time
  comments: [Comment]!
  creationDate: Time!
  description: String
  equipmentToAdd: [Equipment]!
  equipmentToRemove: [Equipment]!
  files: [File]!
  flowInstance: FlowInstance
  hyperlinks: [Hyperlink!]!
  id: ID!
  images: [File]!
  index: Int!
  installDate: Time
  isNameEditable: Boolean
  linksToAdd: [Link]!
  linksToRemove: [Link]!
  location: Location
  name: String!
  organizationFk: Organization
  owner: User!
  priority: WorkOrderPriority!
  project: Project
  properties: [Property]!
  scheduledAt: Time
  status: WorkOrderStatus!
  workOrderTemplate: WorkOrderTemplate
  workOrderType: WorkOrderType!
}

"""A connection to a list of work orders."""
type WorkOrderConnection {
  """A list of work order edges."""
  edges: [WorkOrderEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of work orders in all pages."""
  totalCount: Int!
}

type WorkOrderDefinition implements Node {
  id: ID!
  index: Int
  type: WorkOrderType!
}

input WorkOrderDefinitionInput {
  id: ID
  index: Int
  type: ID!
}

"""A work order edge in a connection."""
type WorkOrderEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The work order at the end of the edge."""
  node: WorkOrder
}

type WorkOrderExecutionResult {
  equipmentAdded: [Equipment!]!
  equipmentRemoved: [ID!]!
  id: ID!
  linkAdded: [Link!]!
  linkRemoved: [ID!]!
  name: String!
}

input WorkOrderFilterInput {
  filterType: WorkOrderFilterType!
  idSet: [ID!]
  maxDepth: Int = 5
  operator: FilterOperator!
  propertyValue: PropertyTypeInput
  stringSet: [String!]
  stringValue: String
  timeValue: Time
}

"""what type of work order we filter about"""
enum WorkOrderFilterType {
  LOCATION_INST
  LOCATION_INST_EXTERNAL_ID
  WORK_ORDER_ASSIGNED_TO
  WORK_ORDER_CLOSE_DATE
  WORK_ORDER_CREATION_DATE
  WORK_ORDER_LOCATION_INST
  WORK_ORDER_NAME
  WORK_ORDER_ORGANIZATION
  WORK_ORDER_OWNED_BY
  WORK_ORDER_PRIORITY
  WORK_ORDER_STATUS
  WORK_ORDER_TYPE
}

"""Ordering options for work order connections."""
input WorkOrderOrder {
  """The ordering direction."""
  direction: OrderDirection!

  """The field to order work orders by."""
  field: WorkOrderOrderField
}

"""Properties by which work order connections can be ordered."""
enum WorkOrderOrderField {
  """Order work orders by closure time."""
  CLOSED_AT

  """Order work orders by creation time."""
  CREATED_AT

  """Order work orders by name."""
  NAME

  """Order work orders by update time."""
  UPDATED_AT
}

"""Work Order priority"""
enum WorkOrderPriority {
  HIGH
  LOW
  MEDIUM
  NONE
  URGENT
}

type WorkOrderSearchResult {
  count: Int!
  workOrders: [WorkOrder]!
}

"""Work Order status"""
enum WorkOrderStatus {
  BLOCKED
  CANCELED
  CLOSED
  DONE @deprecated(reason: "Use new status `CLOSED`, `SUBMITTED` or `BLOCKED` instead. Will be removed on 2020-11-01")
  IN_PROGRESS
  PENDING @deprecated(reason: "Use new status `IN_PROGRESS` instead. Will be removed on 2020-11-01")
  PLANNED
  SUBMITTED
  SUSPENDED
}

"""Payload of the workOrderStatusChanged subscription."""
type WorkOrderStatusChangedPayload {
  """Previous status of the work order."""
  from: WorkOrderStatus

  """Current status of the work order."""
  to: WorkOrderStatus!

  """The work order of which status was modified."""
  workOrder: WorkOrder!
}

type WorkOrderTemplate {
  assigneeCanCompleteWorkOrder: Boolean
  checkListCategoryDefinitions: [CheckListCategoryDefinition!]!
  description: String
  name: String!
  propertyTypes: [PropertyType]!
}

"""Work Order type schema: e.g. construction work."""
type WorkOrderType implements Node {
  assigneeCanCompleteWorkOrder: Boolean
  checkListCategoryDefinitions: [CheckListCategoryDefinition!]!
  description: String
  id: ID!
  name: String!
  numberOfWorkOrders: Int!
  propertyTypes: [PropertyType]!
}

"""A connection to a list of work order types."""
type WorkOrderTypeConnection {
  """A list of work order type edges."""
  edges: [WorkOrderTypeEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of work order types in all pages."""
  totalCount: Int!
}

"""A work order type edge in a connection."""
type WorkOrderTypeEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The work order type at the end of the edge."""
  node: WorkOrderType
}

type WorkerType implements Node {
  description: String
  id: ID!
  name: String!
  propertyTypes: [PropertyType]!
}

"""A connection to a list of worker types."""
type WorkerTypeConnection {
  """A list of worker type edges."""
  edges: [WorkerTypeEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """Total count of worker types in all pages."""
  totalCount: Int!
}

"""An worker type edge in a connection."""
type WorkerTypeEdge {
  """A cursor for use in pagination."""
  cursor: Cursor!

  """The worker type at the end of the edge."""
  node: WorkerType
}

type WorkforceCUD {
  assign: WorkforcePermissionRule!
  create: WorkforcePermissionRule!
  delete: WorkforcePermissionRule!
  transferOwnership: WorkforcePermissionRule!
  update: WorkforcePermissionRule!
}

input WorkforceCUDInput {
  assign: BasicPermissionRuleInput
  create: BasicPermissionRuleInput
  delete: BasicPermissionRuleInput
  transferOwnership: BasicPermissionRuleInput
  update: BasicPermissionRuleInput
}

type WorkforcePermissionRule {
  isAllowed: PermissionValue!
  organizationIds: [ID!]
  projectTypeIds: [ID!]
  workOrderTypeIds: [ID!]
}

input WorkforcePermissionRuleInput {
  isAllowed: PermissionValue!
  organizationIds: [ID!]
  projectTypeIds: [ID!]
  workOrderTypeIds: [ID!]
}

type WorkforcePolicy {
  data: WorkforceCUD!
  read: WorkforcePermissionRule!
  templates: CUD!
}

input WorkforcePolicyInput {
  data: WorkforceCUDInput
  read: WorkforcePermissionRuleInput
  templates: BasicCUDInput
}

enum YesNoResponse {
  NO
  YES
}

enum core__Purpose {
  """
  `EXECUTION` features provide metadata necessary to for operation execution.
  """
  EXECUTION

  """
  `SECURITY` features provide metadata necessary to securely resolve fields.
  """
  SECURITY
}

scalar join__FieldSet

enum join__Graph {
  DGRAPHSERVICE @join__graph(name: "dgraphservice" url: "http://dgraph-dgraph-alpha.dgraph.svc.cluster.local:8080/graphql")
  SYMPHONY @join__graph(name: "symphony" url: "http://symphony-graph/query")
}
